/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["adhere-lib"] = factory();
	else
		root["adhere-lib"] = factory();
})(self, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/AdLeafNode.es6":
/*!****************************!*\
  !*** ./src/AdLeafNode.es6 ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\n\nvar _AudioNub2 = _interopRequireDefault(__webpack_require__(/*! ./AudioNub.es6 */ \"./src/AudioNub.es6\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n// import Logger from \"./Logger.es6\";\nvar Logger = __webpack_require__(/*! ./Logger.es6 */ \"./src/Logger.es6\").Logger; // import TextPresenter from \"./TextPresenter.es6\";\n\n\nvar TextPresenter = __webpack_require__(/*! ./TextPresenter.es6 */ \"./src/TextPresenter.es6\").TextPresenter;\n\nvar defaultOutput = null;\n\nvar AdLeafNode = /*#__PURE__*/function (_AudioNub) {\n  _inherits(AdLeafNode, _AudioNub);\n\n  var _super = _createSuper(AdLeafNode);\n\n  function AdLeafNode(parent, node, audioContext) {\n    var _this;\n\n    _classCallCheck(this, AdLeafNode);\n\n    _this = _super.call(this, parent, node, audioContext);\n\n    if (!_this._name) {\n      _this._name = \"span (anonymous)\";\n    }\n\n    return _this;\n  }\n\n  _createClass(AdLeafNode, [{\n    key: \"makeDefaultOutput\",\n    value: function makeDefaultOutput() {\n      if (defaultOutput) {\n        defaultOutput.onInactive();\n      }\n\n      this.onActive();\n      defaultOutput = this;\n    }\n  }, {\n    key: \"onActive\",\n    value: function onActive() {\n      if (!this.isActive) {\n        this.output.connect(this.audioContext.destination);\n\n        if (defaultOutput && defaultOutput !== this) {\n          defaultOutput.onInactive();\n        }\n\n        Logger.log(\"Active leaf: \".concat(this.pathString));\n      }\n\n      _get(_getPrototypeOf(AdLeafNode.prototype), \"onActive\", this).call(this);\n\n      if (this.value) {\n        this.tpKey = TextPresenter.present(this.value, this.pathString);\n      }\n    }\n  }, {\n    key: \"onInactive\",\n    value: function onInactive() {\n      if (this.isActive) {\n        if (this.tpKey) {\n          TextPresenter.unPresent(this.tpKey);\n        }\n\n        this.output.disconnect(this.audioContext.destination);\n\n        if (defaultOutput && defaultOutput !== this) {\n          defaultOutput.onActive();\n        }\n\n        Logger.log(\"Inactive leaf: \".concat(this.pathString));\n      }\n\n      _get(_getPrototypeOf(AdLeafNode.prototype), \"onInactive\", this).call(this);\n    }\n  }]);\n\n  return AdLeafNode;\n}(_AudioNub2[\"default\"]);\n\nexports.default = AdLeafNode;\n\n//# sourceURL=webpack://adhere-lib/./src/AdLeafNode.es6?");

/***/ }),

/***/ "./src/AdNode.es6":
/*!************************!*\
  !*** ./src/AdNode.es6 ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\n\nvar _Utils = _interopRequireDefault(__webpack_require__(/*! ./Utils.es6 */ \"./src/Utils.es6\"));\n\nvar _TimingCalculator = _interopRequireDefault(__webpack_require__(/*! ./TimingCalculator.es6 */ \"./src/TimingCalculator.es6\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n//import Logger from \"./Logger.es6\";\nvar Logger = __webpack_require__(/*! ./Logger.es6 */ \"./src/Logger.es6\").Logger;\n\nvar AdNode = /*#__PURE__*/function () {\n  function AdNode(parent, xmlNode, audioContext) {\n    _classCallCheck(this, AdNode);\n\n    this._xmlNode = xmlNode;\n    this.parent = parent;\n    this.time = {\n      begin: _TimingCalculator[\"default\"].computeBegin(xmlNode),\n      end: undefined\n    };\n    this._name = xmlNode.name;\n    this._value = xmlNode.value;\n\n    if (xmlNode.attributes) {\n      this._pitch = _Utils[\"default\"].getAttributeByFullyQualifiedName(xmlNode, \"\".concat(_Utils[\"default\"].NS_TTML_AUDIO_URI, \"%%pitch\"));\n      this._speak = _Utils[\"default\"].getAttributeByFullyQualifiedName(xmlNode, \"\".concat(_Utils[\"default\"].NS_TTML_AUDIO_URI, \"%%speak\"));\n      this._id = _Utils[\"default\"].getAttributeByFullyQualifiedName(xmlNode, \"\".concat(_Utils[\"default\"].NS_XML_URI, \"%%id\"));\n    }\n\n    if (audioContext) {\n      this.ac = audioContext;\n    } // Logger.log(`Constructed an AdNode for ${this.pathString}, value \\\"${this.value}\\\"\n    // ${this.begin} --> ${this.end}`); // DEBUG\n\n  }\n\n  _createClass(AdNode, [{\n    key: \"postComputeEnd\",\n    value: function postComputeEnd() {\n      this.time.end = _TimingCalculator[\"default\"].computeEnd(this._xmlNode); // Logger.log(`postComputeEnd() for ${this.pathString}, value \\\"${this.value}\\\"\n      // ${this.begin} --> ${this.end}`); // DEBUG\n\n      if (this.children) {\n        this.children.forEach(function (c) {\n          c.postComputeEnd();\n        });\n      }\n    }\n  }, {\n    key: \"audioContext\",\n    get: function get() {\n      if (this.ac) {\n        return this.ac;\n      }\n\n      if (this.parent) {\n        return this.parent.audioContext;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"begin\",\n    get: function get() {\n      var begin = NaN;\n\n      if (this.time) {\n        begin = this.time.begin;\n      }\n\n      return begin;\n    }\n  }, {\n    key: \"end\",\n    get: function get() {\n      var end = NaN;\n\n      if (this.time) {\n        end = this.time.end;\n      }\n\n      return end;\n    }\n  }, {\n    key: \"pitch\",\n    get: function get() {\n      if (this._pitch || this._pitch === 0) {\n        return this._pitch;\n      } else if (this.parent) {\n        return this.parent.pitch;\n      }\n\n      return undefined;\n    }\n  }, {\n    key: \"speak\",\n    get: function get() {\n      if (this._speak) {\n        return this._speak;\n      } else if (this.parent) {\n        return this.parent.speak;\n      }\n\n      return undefined;\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this._value;\n    }\n  }, {\n    key: \"videoMedia\",\n    get: function get() {\n      return this._videoMedia;\n    },\n    set: function set(vm) {\n      this._videoMedia = vm;\n    }\n  }, {\n    key: \"makeCueObjects\",\n    value: function makeCueObjects(arr, videoMedia) {\n      var _this = this;\n\n      this.videoMedia = videoMedia;\n      var b = this.begin;\n      var e = !isNaN(this.end) ? this.end : videoMedia.duration;\n      var v = this.value;\n\n      if (!isNaN(b) && !isNaN(e)) {\n        // Logger.log(`Making a cue for ${ this.pathString }, \\\"${ v }\\\",\n        // ${b} --> ${e}.`); // DEBUG\n        var newCue = new VTTCue(b, e, v);\n\n        newCue.onenter = function () {\n          return _this.onActive();\n        };\n\n        newCue.onexit = function () {\n          return _this.onInactive();\n        };\n\n        arr.push(newCue); // } else {\n        //   Logger.log(`Not making a cue for ${ this.pathString }, \\\"${ v }\\\"\n        //   because b (${b}) or e (${e}) is NaN.`); // DEBUG\n      }\n\n      if (this.children) {\n        var _iterator = _createForOfIteratorHelper(this.children),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var c = _step.value;\n            c.makeCueObjects(arr, videoMedia);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n    } //Go down the tree, apply fn(c) to all children\n\n  }, {\n    key: \"traverse\",\n    value: function traverse(fn) {\n      fn(this);\n\n      if (this.children) {\n        var _iterator2 = _createForOfIteratorHelper(this.children),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var c = _step2.value;\n            c.traverse(fn);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return this._name;\n    }\n  }, {\n    key: \"pathString\",\n    get: function get() {\n      return (this.parent ? \"\".concat(this.parent.pathString, \" -> \") : \"\") + \"\".concat(this.name).concat(this.idString);\n    }\n  }, {\n    key: \"idString\",\n    get: function get() {\n      return this._id ? \" id:\\\"\".concat(this._id, \"\\\"\") : \"\";\n    }\n  }, {\n    key: \"onActive\",\n    value: function onActive() {\n      this.isActive = true;\n      Logger.log(\"Active AdNode: \".concat(this.pathString));\n    }\n  }, {\n    key: \"onInactive\",\n    value: function onInactive() {\n      this.isActive = false;\n      Logger.log(\"Inactive AdNode: \".concat(this.pathString));\n    }\n  }, {\n    key: \"onFinalise\",\n    value: function onFinalise() {\n      if (this.isActive) {\n        this.onInactive();\n      }\n    }\n  }]);\n\n  return AdNode;\n}();\n\nexports.default = AdNode;\n\n//# sourceURL=webpack://adhere-lib/./src/AdNode.es6?");

/***/ }),

/***/ "./src/AdSourceNode.es6":
/*!******************************!*\
  !*** ./src/AdSourceNode.es6 ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\n\nvar _AudioNub2 = _interopRequireDefault(__webpack_require__(/*! ./AudioNub.es6 */ \"./src/AudioNub.es6\"));\n\nvar _TimingCalculator = _interopRequireDefault(__webpack_require__(/*! ./TimingCalculator.es6 */ \"./src/TimingCalculator.es6\"));\n\nvar _PlaybackProperties = _interopRequireDefault(__webpack_require__(/*! ./PlaybackProperties.es6 */ \"./src/PlaybackProperties.es6\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n// import Logger from \"./Logger.es6\";\nvar Logger = __webpack_require__(/*! ./Logger.es6 */ \"./src/Logger.es6\").Logger;\n\nvar readyStateMap = {\n  0: \"HAVE_NOTHING\",\n  1: \"HAVE_METADATA\",\n  2: \"HAVE_CURRENT_DATA\",\n  3: \"HAVE_FUTURE_DATA\",\n  4: \"HAVE_ENOUGH_DATA\"\n}; // This guy is a little weird - It's the input to it's parent; i.e. in the graph\n// it is the parent, but in the tree (and xml), it's a child.\n// Don't use it for user controlled sources like video elements:\n// instead user AdUserControlledSourceNode for them.\n\nvar AdSourceNode = /*#__PURE__*/function (_AudioNub) {\n  _inherits(AdSourceNode, _AudioNub);\n\n  var _super = _createSuper(AdSourceNode);\n\n  function AdSourceNode(parent, xmlNode, audioContext, mediaPair) {\n    var _this;\n\n    _classCallCheck(this, AdSourceNode);\n\n    _this = _super.call(this, parent, xmlNode, audioContext);\n    _this.mediaPair = mediaPair;\n    _this.media = mediaPair.media;\n    _this.mediaNode = mediaPair.mediaNode;\n\n    if (xmlNode.attributes.clipBegin) {\n      _this.clipBegin = _TimingCalculator[\"default\"].parseSeconds(xmlNode.attributes.clipBegin) || 0;\n    } else {\n      _this.clipBegin = 0;\n    }\n\n    if (xmlNode.attributes.clipEnd) {\n      _this.clipEnd = _TimingCalculator[\"default\"].parseSeconds(xmlNode.attributes.clipEnd) || NaN;\n    }\n\n    return _this;\n  }\n\n  _createClass(AdSourceNode, [{\n    key: \"mediaReadyState\",\n    value: function mediaReadyState(m) {\n      var readyState = m.readyState;\n      return readyStateMap[readyState];\n    }\n  }, {\n    key: \"addDebugEventHandlers\",\n    value: function addDebugEventHandlers() {\n      var _this2 = this;\n\n      var m = this.mediaPair.media;\n\n      if (m) {\n        m.addEventListener(\"abort\", function () {\n          Logger.log(\"Audio source aborted loading. readyState = \".concat(_this2.mediaReadyState(m)));\n        });\n        m.addEventListener(\"error\", function () {\n          Logger.log(\"Audio source error. readyState = \".concat(_this2.mediaReadyState(m)));\n        });\n        m.addEventListener(\"loadeddata\", function () {\n          Logger.log(\"Audio source loaded data. readyState = \".concat(_this2.mediaReadyState(m)));\n        });\n        m.addEventListener(\"loadstart\", function () {\n          Logger.log(\"Audio source loadstart. readyState = \".concat(_this2.mediaReadyState(m)));\n        });\n        m.addEventListener(\"playing\", function () {\n          Logger.log(\"Audio source is playing. readyState = \".concat(_this2.mediaReadyState(m)));\n        });\n        m.addEventListener(\"progress\", function () {\n          Logger.log(\"Audio source making progress. readyState = \".concat(_this2.mediaReadyState(m)));\n        });\n        m.addEventListener(\"waiting\", function () {\n          Logger.log(\"Audio source is waiting for more data. readyState = \".concat(_this2.mediaReadyState(m)));\n        });\n      }\n    }\n  }, {\n    key: \"end\",\n    get: function get() {\n      var ret;\n\n      var normalEnd = _get(_getPrototypeOf(AdSourceNode.prototype), \"end\", this);\n\n      if (this.clipEnd) {\n        //The duration of the clip added to the start time, or the span end, whichever comes first.\n        ret = Math.min(normalEnd, this.begin + (this.clipEnd - this.clipBegin));\n      } else {\n        ret = normalEnd;\n      } // Logger.log(`AdSourceNode end() super said ${normalEnd} but I'm saying ${ret}`); // DEBUG\n\n\n      return ret;\n    }\n  }, {\n    key: \"onActive\",\n    value: function onActive() {\n      var _this3 = this;\n\n      if (this.mediaPair && !this.isActive) {\n        Logger.log(\"Active AdSourceNode: \".concat(this.pathString));\n        var offset = this.videoMedia.currentTime - this.begin;\n        this.media.currentTime = this.clipBegin ? this.clipBegin + offset : offset;\n        this.input = this.mediaNode;\n        this.gainNode.gain.value = this.gain * _PlaybackProperties[\"default\"].getCurrentGain();\n        this.input.connect(this.gainNode);\n        Logger.log(\"Connected to media element source with src= \".concat(this.input.mediaElement.currentSrc));\n        this.media.play()[\"catch\"](function (e) {\n          Logger.log(\"AdSourceNode play rejected with error: \".concat(e, \".\"));\n        });\n        this.output.connect(this.parent.gainNode); //TODO Make formal with .input\n\n        Logger.log(\"Active source into: \".concat(this.parent.name, \"; src: \").concat(this.media.src, \"; from: \").concat(this.media.currentTime, \" including offset of \").concat(offset, \".\"));\n        this.startTime = this.media.currentTime;\n        this.isActive = true;\n        this.gainId = _PlaybackProperties[\"default\"].registerCallback(function (uiGain) {\n          //const oldVal = this.gainNode.gain.value;\n          //console.info(\"Base gain\", this.gain, \"UI gain\", uiGain);\n          _this3.gainNode.gain.value = _this3.gain * uiGain; //console.info(\"Final gain changes from\", oldVal, \"to\", this.gainNode.gain.value);\n        });\n      }\n    }\n  }, {\n    key: \"onInactive\",\n    value: function onInactive() {\n      if (this.media && this.isActive) {\n        Logger.log(\"Inactive AdSourceNode: \".concat(this.pathString));\n        this.media.pause();\n        this.input.disconnect(this.gainNode);\n        this.input = null;\n        this.output.disconnect(this.parent.gainNode);\n        Logger.log(\"Inactive source into: \".concat(this.parent.name, \"; src: \").concat(this.media.src));\n        this.endTime = this.media.currentTime; // DEBUG: clipBegin/clipEnd\n\n        Logger.log( // eslint-disable-next-line max-len\n        \"ran source for: \".concat(this.endTime - this.startTime, \" clipBegin: \").concat(this.startTime, \" clipEnd: \").concat(this.endTime));\n        this.isActive = false;\n\n        _PlaybackProperties[\"default\"].deregisterCallback(this.gainId);\n      }\n    }\n  }, {\n    key: \"onPause\",\n    value: function onPause() {\n      if (this.media && this.isActive) {\n        this.media.pause();\n      }\n    }\n  }, {\n    key: \"onRestart\",\n    value: function onRestart() {\n      if (this.media && this.isActive) {\n        this.media.play();\n      }\n    }\n  }, {\n    key: \"onFinalise\",\n    value: function onFinalise() {\n      if (this.media) {\n        _get(_getPrototypeOf(AdSourceNode.prototype), \"onFinalise\", this).call(this);\n\n        var src = this.media.src;\n\n        if ((src + \"\").indexOf(\"blob://\") > 0) {\n          Logger.log(\"Clear audio src \" + this.media.src);\n          this.media.src = \"\";\n          URL.revokeObjectURL(src);\n        }\n\n        if (this.input) {\n          this.input.disconnect(this.gainNode);\n        }\n      }\n    }\n  }]);\n\n  return AdSourceNode;\n}(_AudioNub2[\"default\"]);\n\nexports.default = AdSourceNode;\n\n//# sourceURL=webpack://adhere-lib/./src/AdSourceNode.es6?");

/***/ }),

/***/ "./src/AdUserControlledSourceNode.es6":
/*!********************************************!*\
  !*** ./src/AdUserControlledSourceNode.es6 ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\n\nvar _AdSourceNode2 = _interopRequireDefault(__webpack_require__(/*! ./AdSourceNode.es6 */ \"./src/AdSourceNode.es6\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n// import Logger from \"./Logger.es6\";\nvar Logger = __webpack_require__(/*! ./Logger.es6 */ \"./src/Logger.es6\").Logger; // This guy is a little weird - It's the input to it's parent; i.e. in the graph\n// it is the parent, but in the tree (and xml), it's a child.\n// This subclass is for user controlled sources like <video> elements, as\n// opposed to sources generated by the TTML source document.\n\n\nvar AdUserControlledSourceNode = /*#__PURE__*/function (_AdSourceNode) {\n  _inherits(AdUserControlledSourceNode, _AdSourceNode);\n\n  var _super = _createSuper(AdUserControlledSourceNode);\n\n  function AdUserControlledSourceNode(parent, xmlNode, audioContext, media) {\n    _classCallCheck(this, AdUserControlledSourceNode);\n\n    return _super.call(this, parent, xmlNode, audioContext, media);\n  }\n\n  _createClass(AdUserControlledSourceNode, [{\n    key: \"onActive\",\n    value: function onActive() {\n      if (this.media && !this.isActive) {\n        this.input = this.mediaNode;\n        this.input.connect(this.gainNode);\n        Logger.log(\"Connected to media element source with src= \".concat(this.input.mediaElement.currentSrc));\n\n        if (this.parent) {\n          this.output.connect(this.parent.gainNode); //TODO Make formal with .input\n\n          Logger.log(\"Active source into: \".concat(this.parent.name, \"; src: \").concat(this.media.src, \"; from: \").concat(this.media.currentTime));\n        } else {\n          Logger.log(\"No parent to connect\");\n        }\n\n        this.startTime = this.media.currentTime;\n        this.isActive = true;\n      }\n    }\n  }, {\n    key: \"onInactive\",\n    value: function onInactive() {\n      if (this.media && this.isActive) {\n        this.input.disconnect(this.gainNode);\n        this.input = null;\n\n        if (this.parent) {\n          this.output.disconnect(this.parent.gainNode);\n          Logger.log(\"Inactive source into: \".concat(this.parent.name, \"; src: \").concat(this.media.src));\n        } else {\n          Logger.log(\"No parent to disconnect\");\n        }\n\n        this.endTime = this.media.currentTime;\n        this.isActive = false;\n      }\n    }\n  }, {\n    key: \"onPause\",\n    value: function onPause() {}\n  }, {\n    key: \"onRestart\",\n    value: function onRestart() {}\n  }, {\n    key: \"onFinalise\",\n    value: function onFinalise() {}\n  }]);\n\n  return AdUserControlledSourceNode;\n}(_AdSourceNode2[\"default\"]);\n\nexports.default = AdUserControlledSourceNode;\n\n//# sourceURL=webpack://adhere-lib/./src/AdUserControlledSourceNode.es6?");

/***/ }),

/***/ "./src/AnimateNode.es6":
/*!*****************************!*\
  !*** ./src/AnimateNode.es6 ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\n\nvar _AdNode2 = _interopRequireDefault(__webpack_require__(/*! ./AdNode.es6 */ \"./src/AdNode.es6\"));\n\nvar _Utils = _interopRequireDefault(__webpack_require__(/*! ./Utils.es6 */ \"./src/Utils.es6\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n// import Logger from \"./Logger.es6\";\nvar Logger = __webpack_require__(/*! ./Logger.es6 */ \"./src/Logger.es6\").Logger;\n\nvar AnimateNode = /*#__PURE__*/function (_AdNode) {\n  _inherits(AnimateNode, _AdNode);\n\n  var _super = _createSuper(AnimateNode);\n\n  function AnimateNode(parent, xmlNode, audioContext) {\n    var _this;\n\n    _classCallCheck(this, AnimateNode);\n\n    _this = _super.call(this, parent, xmlNode, audioContext);\n\n    if (_Utils[\"default\"].getAttributeByFullyQualifiedName(xmlNode, \"\".concat(_Utils[\"default\"].NS_TTML_AUDIO_URI, \"%%gain\"))) {\n      _this.gains = _Utils[\"default\"].getAttributeByFullyQualifiedName(xmlNode, \"\".concat(_Utils[\"default\"].NS_TTML_AUDIO_URI, \"%%gain\")).split(\";\").map(parseFloat);\n    }\n\n    if (_Utils[\"default\"].getAttributeByFullyQualifiedName(xmlNode, \"\".concat(_Utils[\"default\"].NS_TTML_AUDIO_URI, \"%%pan\"))) {\n      _this.pans = _Utils[\"default\"].getAttributeByFullyQualifiedName(xmlNode, \"\".concat(_Utils[\"default\"].NS_TTML_AUDIO_URI, \"%%pan\")).split(\";\").map(parseFloat);\n    }\n\n    return _this;\n  }\n\n  _createClass(AnimateNode, [{\n    key: \"onActive\",\n    value: function onActive() {\n      _get(_getPrototypeOf(AnimateNode.prototype), \"onActive\", this).call(this);\n\n      var duration = this.end - this.begin;\n\n      if (this.gains && this.gains.length > 0) {\n        this.parent.gainNode.gain.setValueCurveAtTime(Float32Array.from(this.gains), this.audioContext.currentTime, duration);\n        Logger.log( // eslint-disable-next-line max-len\n        \"Active animate node into: \".concat(this.parent.name, \"; gain: \").concat(this.gains.join(\", \"), \"; dur: \").concat(duration));\n      }\n\n      if (this.pans && this.pans.length > 0) {\n        // Try to work around older spec support in Webkit, noting that\n        // the PannerNode interface does not use AudioParam and therefore\n        // the attempt to use setValueCurveAtTime fails.\n        var panPosition = this.parent.panNode.pan || this.parent.panNode.position;\n        panPosition.setValueCurveAtTime(Float32Array.from(this.pans), this.audioContext.currentTime, duration);\n        Logger.log( // eslint-disable-next-line max-len\n        \"Active animate node into: \".concat(this.parent.name, \"; pan: \").concat(this.pans.join(\", \"), \"; dur: \").concat(duration));\n      }\n    }\n  }, {\n    key: \"onInactive\",\n    value: function onInactive() {\n      _get(_getPrototypeOf(AnimateNode.prototype), \"onInactive\", this).call(this);\n    }\n  }]);\n\n  return AnimateNode;\n}(_AdNode2[\"default\"]);\n\nexports.default = AnimateNode;\n\n//# sourceURL=webpack://adhere-lib/./src/AnimateNode.es6?");

/***/ }),

/***/ "./src/AudioNub.es6":
/*!**************************!*\
  !*** ./src/AudioNub.es6 ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\n\nvar _AdNode2 = _interopRequireDefault(__webpack_require__(/*! ./AdNode.es6 */ \"./src/AdNode.es6\"));\n\nvar _Utils = _interopRequireDefault(__webpack_require__(/*! ./Utils.es6 */ \"./src/Utils.es6\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar AudioNub = /*#__PURE__*/function (_AdNode) {\n  _inherits(AudioNub, _AdNode);\n\n  var _super = _createSuper(AudioNub);\n\n  function AudioNub(parent, xmlNode, audioContext) {\n    var _this;\n\n    _classCallCheck(this, AudioNub);\n\n    _this = _super.call(this, parent, xmlNode, audioContext);\n\n    _this.copyAudioAttributes(xmlNode);\n\n    _this.createAudioNodes();\n\n    return _this;\n  }\n\n  _createClass(AudioNub, [{\n    key: \"createAudioNodes\",\n    value: function createAudioNodes() {\n      this.gainNode = this.audioContext.createGain(); // Check that StereoPanner is supported. Webkit currently only\n      // supports the older interface's Panner.\n\n      var supportsStereoPanner = this.audioContext.createStereoPanner;\n      var supportsPanner = this.audioContext.createPanner;\n\n      if (supportsStereoPanner) {\n        this.panNode = this.audioContext.createStereoPanner();\n      } else if (supportsPanner) {\n        this.panNode = this.audioContext.createPanner();\n      }\n\n      this.gainNode.connect(this.panNode);\n      this.output = this.panNode;\n\n      if (supportsStereoPanner) {\n        this.panNode.pan.value = this.pan;\n      } else if (supportsPanner) {\n        this.panNode.position = 90 * this.pan;\n      }\n\n      this.gainNode.gain.value = this.gain;\n    }\n  }, {\n    key: \"onActive\",\n    value: function onActive() {\n      if (this.parent && !this.isActive) {\n        this.parent.output.connect(this.gainNode);\n      }\n\n      _get(_getPrototypeOf(AudioNub.prototype), \"onActive\", this).call(this);\n    }\n  }, {\n    key: \"onInactive\",\n    value: function onInactive() {\n      if (this.parent && this.isActive) {\n        this.parent.output.disconnect(this.gainNode);\n      }\n\n      _get(_getPrototypeOf(AudioNub.prototype), \"onInactive\", this).call(this);\n    }\n  }, {\n    key: \"onFinalise\",\n    value: function onFinalise() {\n      _get(_getPrototypeOf(AudioNub.prototype), \"onFinalise\", this).call(this);\n\n      this.gainNode.disconnect(this.panNode);\n    }\n  }, {\n    key: \"gain\",\n    get: function get() {\n      return !isNaN(this._gain) ? this._gain : 1;\n    }\n  }, {\n    key: \"pan\",\n    get: function get() {\n      return !isNaN(this._pan) ? this._pan : 0;\n    }\n  }, {\n    key: \"copyAudioAttributes\",\n    value: function copyAudioAttributes(xmlNode) {\n      if (xmlNode.attributes) {\n        this._gain = parseFloat(_Utils[\"default\"].getAttributeByFullyQualifiedName(xmlNode, \"\".concat(_Utils[\"default\"].NS_TTML_AUDIO_URI, \"%%gain\")));\n        this._pan = parseFloat(_Utils[\"default\"].getAttributeByFullyQualifiedName(xmlNode, \"\".concat(_Utils[\"default\"].NS_TTML_AUDIO_URI, \"%%pan\")));\n      }\n    }\n  }]);\n\n  return AudioNub;\n}(_AdNode2[\"default\"]);\n\nexports.default = AudioNub;\n\n//# sourceURL=webpack://adhere-lib/./src/AudioNub.es6?");

/***/ }),

/***/ "./src/Logger.es6":
/*!************************!*\
  !*** ./src/Logger.es6 ***!
  \************************/
/***/ ((module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// Copyright 2019 British Broadcasting Corporation\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar callbacks = [];\nvar consoleEnabled = false;\nvar callbacksEnabled = true;\nvar videoplayer;\n/*eslint no-console: [\"error\", { allow: [\"warn\", \"error\", \"log\", \"dir\"] }] */\n\nvar Logger = /*#__PURE__*/function () {\n  function Logger() {\n    _classCallCheck(this, Logger);\n  }\n\n  _createClass(Logger, null, [{\n    key: \"log\",\n    value: function log(str) {\n      if (videoplayer) {\n        str = \"\".concat(videoplayer.currentTime.toFixed(3).padStart(8, \" \"), \" \").concat(str);\n      }\n\n      if (consoleEnabled) {\n        console.log(str);\n      }\n\n      if (callbacksEnabled) {\n        callbacks.forEach(function (cb) {\n          return cb(str);\n        });\n      }\n    }\n  }, {\n    key: \"addCallback\",\n    value: function addCallback(cb) {\n      callbacks.push(cb);\n    }\n  }, {\n    key: \"enableBrowserLogging\",\n    value: function enableBrowserLogging(value) {\n      consoleEnabled = value;\n    }\n  }, {\n    key: \"error\",\n    value: function error(str) {\n      if (consoleEnabled) {\n        console.error(str);\n      }\n\n      if (callbacksEnabled) {\n        callbacks.forEach(function (cb) {\n          return cb(str);\n        });\n      }\n    }\n  }, {\n    key: \"enableCallbacks\",\n    value: function enableCallbacks(value) {\n      if (consoleEnabled) {\n        console.log(\"Setting consoleEnabled to \".concat(value, \".\"));\n      }\n\n      callbacksEnabled = value;\n    }\n  }, {\n    key: \"setVideoPlayer\",\n    value: function setVideoPlayer(player) {\n      videoplayer = player;\n\n      if (videoplayer) {\n        this.log(\"Videoplayer set, log lines will be prefixed with video player currentTime.\");\n      } else {\n        this.log(\"Videoplayer unset, log lines will not have a timestamp.\");\n      }\n    }\n  }]);\n\n  return Logger;\n}();\n\nexports.default = Logger;\nmodule.exports = exports = {\n  Logger: Logger\n};\n\n//# sourceURL=webpack://adhere-lib/./src/Logger.es6?");

/***/ }),

/***/ "./src/Parser.es6":
/*!************************!*\
  !*** ./src/Parser.es6 ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = parseTree;\nexports.setAudioCacheStrategy = setAudioCacheStrategy;\nexports.getAudioCacheStrategy = getAudioCacheStrategy;\n\nvar _Utils = _interopRequireDefault(__webpack_require__(/*! ./Utils.es6 */ \"./src/Utils.es6\"));\n\nvar _AdSourceNode = _interopRequireDefault(__webpack_require__(/*! ./AdSourceNode.es6 */ \"./src/AdSourceNode.es6\"));\n\nvar _AdLeafNode = _interopRequireDefault(__webpack_require__(/*! ./AdLeafNode.es6 */ \"./src/AdLeafNode.es6\"));\n\nvar _AdUserControlledSourceNode = _interopRequireDefault(__webpack_require__(/*! ./AdUserControlledSourceNode.es6 */ \"./src/AdUserControlledSourceNode.es6\"));\n\nvar _SpeechSourceNode = _interopRequireDefault(__webpack_require__(/*! ./SpeechSourceNode.es6 */ \"./src/SpeechSourceNode.es6\"));\n\nvar _AudioNub = _interopRequireDefault(__webpack_require__(/*! ./AudioNub.es6 */ \"./src/AudioNub.es6\"));\n\nvar _AnimateNode = _interopRequireDefault(__webpack_require__(/*! ./AnimateNode.es6 */ \"./src/AnimateNode.es6\"));\n\nvar _base64Js = _interopRequireDefault(__webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n// import Logger from \"./Logger.es6\";\nvar Logger = __webpack_require__(/*! ./Logger.es6 */ \"./src/Logger.es6\").Logger;\n\nvar CACHE_STRATEGY_REUSE = true;\nvar CACHE_STRATEGY_NOCACHE = false;\nvar currentUrl = \"\";\nvar audioElements = {};\nvar audioResources = {};\nvar trackPrefix = \";track=\";\nvar defaultVideoGain = 1;\nvar audioCacheStrategy = CACHE_STRATEGY_NOCACHE;\n/*eslint func-style: [\"error\", \"declaration\"]*/\n\n/*eslint no-use-before-define: [\"error\", { \"functions\": false }]*/\n\n/*eslint max-statements: [\"error\", 25]*/\n\nfunction isName(fullyQualifiedName, node) {\n  return node.fullyQualifiedName === fullyQualifiedName;\n}\n\nfunction getNamedChildren(fullyQualifiedName, node) {\n  return node.children.filter(isName.bind(null, fullyQualifiedName));\n} //For an audio with a <source> element, make a mediaSrc url from the base64.\n\n\nfunction parseEmbeddedSource(node) {\n  var source = getNamedChildren(\"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%source\"), node)[0];\n  var data = getNamedChildren(\"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%data\"), source)[0];\n  var dataType = data.attributes.type;\n  var chunks = getNamedChildren(\"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%chunk\"), data);\n  var chunk = chunks[0]; //TODO: merge multiple chunks\n\n  if (chunk.children.length > 0) {\n    chunk.value = chunk.children[0].value;\n  }\n\n  var wsRegex = /\\s/gi; // eslint-disable-next-line no-undef\n\n  var dataChunk = _base64Js[\"default\"].toByteArray(chunk.value.replace(wsRegex, \"\"));\n\n  var blob = new Blob([dataChunk], {\n    type: dataType\n  });\n  return URL.createObjectURL(blob);\n}\n\nfunction grabAudioResources(headNode) {\n  var ret = {};\n  var resources = getNamedChildren(\"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%resources\"), headNode)[0];\n\n  if (resources) {\n    var audios = getNamedChildren(\"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%audio\"), resources);\n\n    var _iterator = _createForOfIteratorHelper(audios),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var a = _step.value;\n\n        var id = _Utils[\"default\"].getAttributeByFullyQualifiedName(a, \"\".concat(_Utils[\"default\"].NS_XML_URI, \"%%id\"));\n\n        if (id) {\n          audioResources[id] = parseEmbeddedSource(a);\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  return ret;\n}\n\nfunction getAudioElement(audioSrc, audioContext) {\n  if (audioCacheStrategy === CACHE_STRATEGY_REUSE && audioSrc in audioElements) {\n    // Yay reuse this one\n    return audioElements[audioSrc];\n  } // Need to make one\n\n\n  var media = new Audio();\n\n  media.onError = function () {\n    Logger.error(\"Error \".concat(media.error.code, \"; details: \").concat(media.error.message));\n  };\n\n  media.src = audioSrc;\n  media.preload = \"metadata\";\n  var node = audioContext.createMediaElementSource(media);\n  var pair = {\n    media: media,\n    mediaNode: node\n  };\n\n  if (audioCacheStrategy === CACHE_STRATEGY_REUSE) {\n    audioElements[audioSrc] = pair;\n  }\n\n  return pair;\n}\n\nfunction propagateNamespaces(xmlNode) {\n  if (xmlNode.parent === null) {\n    xmlNode.namespaces = _Utils[\"default\"].gleanNamespaces(xmlNode);\n    xmlNode.fullyQualifiedName = _Utils[\"default\"].getFullyQualifiedName(xmlNode);\n  }\n\n  if (xmlNode.children) {\n    var _iterator2 = _createForOfIteratorHelper(xmlNode.children),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var c = _step2.value;\n\n        if (c.parent === null || c.parent.namespaces === {}) {\n          c.namespaces = _Utils[\"default\"].gleanNamespaces(c);\n        } else {\n          c.namespaces = Object.assign(c.parent.namespaces, _Utils[\"default\"].gleanNamespaces(c));\n        }\n\n        c.fullyQualifiedName = _Utils[\"default\"].getFullyQualifiedName(c);\n        propagateNamespaces(c);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n} //The xml parser makes anonymous spans under real spans, let's flatten the two together.\n\n\nfunction flattenSpans(xmlNode) {\n  if (xmlNode.children) {\n    for (var i = 0; i < xmlNode.children.length;) {\n      var c = xmlNode.children[i];\n\n      if ((xmlNode.fullyQualifiedName === \"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%span\") || xmlNode.fullyQualifiedName === \"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%chunk\")) && c.fullyQualifiedName === \"\") {\n        xmlNode.value = c.value; //Take the text inside it\n\n        xmlNode.children.splice(i, 1);\n      } else {\n        flattenSpans(c);\n        i++;\n      }\n    }\n  }\n} //remove any nodes that don't fall under the isAudioType definition\n//clear out the unrelated ttml stuff\n\n\nfunction removeOther(xmlNode) {\n  if (xmlNode.children) {\n    for (var i = 0; i < xmlNode.children.length;) {\n      var c = xmlNode.children[i];\n\n      if (!_Utils[\"default\"].isAudioType(c.fullyQualifiedName)) {\n        xmlNode.children.splice(i, 1);\n      } else {\n        removeOther(c);\n        i++;\n      }\n    }\n  }\n}\n\nfunction siblingsHaveAudio(xmlNode) {\n  var siblings = xmlNode.parent.children;\n\n  var _iterator3 = _createForOfIteratorHelper(siblings),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var s = _step3.value;\n\n      // eslint-disable-next-line eqeqeq\n      if (s != xmlNode && s.fullyQualifiedName === \"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%audio\")) {\n        return true;\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return false;\n}\n\nfunction markAudio(xmlNode) {\n  if (xmlNode.parent) {\n    xmlNode.hasAudio = xmlNode.parent.hasAudio;\n  }\n\n  if (_Utils[\"default\"].isAudioElement(xmlNode) || (xmlNode.fullyQualifiedName === \"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%p\") || xmlNode.fullyQualifiedName === \"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%div\") || xmlNode.fullyQualifiedName === \"\" || xmlNode.fullyQualifiedName === \"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%span\")) && siblingsHaveAudio(xmlNode)) {\n    xmlNode.hasAudio = true;\n  }\n\n  if (xmlNode.children) {\n    var _iterator4 = _createForOfIteratorHelper(xmlNode.children),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var c = _step4.value;\n        markAudio(c);\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n\n    xmlNode.hasAudio = xmlNode.hasAudio || xmlNode.children.some(function (c) {\n      return c.hasAudio;\n    });\n  }\n}\n\nfunction markSpeech(xmlNode, parentSpeech) {\n  var speechSpecified = false;\n\n  if (xmlNode.attributes) {\n    var speakAttribute = _Utils[\"default\"].getAttributeByFullyQualifiedName(xmlNode, \"\".concat(_Utils[\"default\"].NS_TTML_AUDIO_URI, \"%%speak\"));\n\n    if (speakAttribute) {\n      speechSpecified = true;\n      xmlNode.hasSpeech = !(speakAttribute === \"none\");\n    }\n  }\n\n  if (!speechSpecified) {\n    // it's inherited downwards, if I don't specify, I get what my parent specifies.\n    xmlNode.hasSpeech = parentSpeech;\n  }\n\n  if (xmlNode.children) {\n    var hasSpeech = xmlNode.hasSpeech;\n\n    var _iterator5 = _createForOfIteratorHelper(xmlNode.children),\n        _step5;\n\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var c = _step5.value;\n        var thisChildHasSpeech = markSpeech(c, hasSpeech);\n        xmlNode.hasSpeech = thisChildHasSpeech || xmlNode.hasSpeech; //If any children have speech, I have speech (but that doesn't mean all my children do).\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n  }\n\n  return xmlNode.hasSpeech;\n}\n\nfunction removeNotAudio(xmlNode) {\n  //Remove anythin without .hasAudio or .hasSpeech.\n  if (xmlNode.children) {\n    for (var i = 0; i < xmlNode.children.length;) {\n      var c = xmlNode.children[i];\n\n      if (c.hasAudio || c.hasSpeech) {\n        removeNotAudio(c);\n        i++;\n      } else {\n        xmlNode.children.splice(i, 1);\n      }\n    }\n  }\n}\n\nfunction prepareXML(xmlNode) {\n  propagateNamespaces(xmlNode);\n  flattenSpans(xmlNode);\n  removeOther(xmlNode); //Mark nodes for hasSpeech and hasAudio\n  //Basically am I used in the pathway; if I or my descendants or my ascendants\n  //have speech or audio attributes, I'm marked too.\n\n  markAudio(xmlNode);\n  markSpeech(xmlNode);\n  removeNotAudio(xmlNode);\n}\n\nfunction parseAnimateNode(parent, node, audioContext) {\n  var ret = new _AnimateNode[\"default\"](parent, node, audioContext);\n  return ret;\n}\n\nfunction isLeafNode(node) {\n  return node.fullyQualifiedName === \"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%span\") || node.fullyQualifiedName === \"\"; //span or anonymous span/\n}\n\nfunction parseSpeechNode(parent, node, audioContext) {\n  var ret = new _SpeechSourceNode[\"default\"](parent, node, audioContext);\n  return ret;\n}\n\nfunction parseAudioSourceNode(parent, node) {\n  var src = node.attributes.src;\n\n  if (src && src.indexOf(trackPrefix) >= 0) {\n    //Ignore body level track specifiers.\n    return undefined;\n  }\n\n  var audioSrc;\n\n  if (src) {\n    if (src.indexOf(\"#\") === 0) {\n      audioSrc = audioResources[src.substring(1)];\n    } else {\n      audioSrc = currentUrl + src;\n    }\n  } else if (!src && node.children) {\n    audioSrc = parseEmbeddedSource(node);\n  } else {\n    Logger.error(\"Found an audio node but couldn't work out what its source is supposed to be.\");\n  }\n\n  var ret;\n\n  if (audioSrc) {\n    var mediaPair = getAudioElement(audioSrc, parent.audioContext);\n    ret = new _AdSourceNode[\"default\"](parent, node, undefined, mediaPair);\n  }\n\n  return ret;\n}\n\nfunction parseNode(parent, node) {\n  var ret = null;\n\n  if (node.fullyQualifiedName === \"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%audio\")) {\n    ret = parseAudioSourceNode(parent, node);\n  } else if (node.fullyQualifiedName === \"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%animate\")) {\n    ret = parseAnimateNode(parent, node);\n  } else if (isLeafNode(node)) {\n    ret = parseLeafNode(parent, node);\n  } else {\n    ret = parseIntermediateNode(parent, node);\n  }\n\n  return ret;\n}\n\nfunction parseLeafNode(parent, node, audioContext) {\n  var ret = new _AdLeafNode[\"default\"](parent, node, audioContext);\n  ret.children = node.children.map(parseNode.bind(null, ret)); //Remove nulls. These are nodes to nowhere. We should also remove anonymous spans if we're a leaf.\n\n  ret.children = ret.children.filter(function (n) {\n    return !!n && (n._xmlNode.fullyQualifiedName === \"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%audio\") || n._xmlNode.fullyQualifiedName === \"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%animate\"));\n  });\n\n  if (node.hasSpeech) {\n    ret.children.push(parseSpeechNode(ret, node, audioContext));\n  }\n\n  return ret;\n}\n\nfunction parseIntermediateNode(parent, node, audioContext) {\n  var ret = new _AudioNub[\"default\"](parent, node, audioContext);\n  ret.children = node.children.map(parseNode.bind(null, ret));\n  ret.children = ret.children.filter(function (n) {\n    return !!n;\n  }); //Remove nulls. These are nodes to nowhere\n\n  return ret;\n}\n\nfunction parseBody(parent, node, audioContext) {\n  var body = parseNode(parent, node, audioContext);\n  body.postComputeEnd();\n  return body;\n}\n\nfunction parseTree(audioContext, media, url, xmlTree, startRoot) {\n  var root;\n\n  if (startRoot) {\n    //We can't make a new AdSourceNode on the media without\n    root = startRoot;\n  } else {\n    //Make an magic source node for the media - there's no xml for this so fake it.\n    var mediaPair = {\n      media: media,\n      mediaNode: audioContext.createMediaElementSource(media)\n    };\n    root = new _AdUserControlledSourceNode[\"default\"](null, {\n      name: \"root(mediaAudio)\",\n      attributes: {\n        \"tta:gain\": defaultVideoGain,\n        \"tta:pan\": 0\n      },\n      namespaces: {\n        \"default\": _Utils[\"default\"].NS_TTML_URI,\n        \"xml\": _Utils[\"default\"].NS_XML_URI,\n        \"tta\": \"\".concat(_Utils[\"default\"].NS_TTML_AUDIO_URI)\n      },\n      fullyQualifiedName: \"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%tt\")\n    }, audioContext, mediaPair);\n  }\n\n  var defaultOutput = new _AdLeafNode[\"default\"](root, {\n    name: \"default audio out\",\n    attributes: {},\n    namespaces: {\n      \"xml\": _Utils[\"default\"].NS_XML_URI\n    },\n    fullyQualifiedName: \"\"\n  }, audioContext);\n  defaultOutput.makeDefaultOutput();\n  root.children = [defaultOutput];\n\n  if (typeof url === \"string\") {\n    currentUrl = \"\".concat(url.slice(0, url.lastIndexOf(\"/\")), \"/\");\n  } else {\n    currentUrl = \"\";\n  }\n\n  prepareXML(xmlTree);\n  var head = getNamedChildren(\"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%head\"), xmlTree)[0];\n\n  if (head) {\n    grabAudioResources(head);\n  }\n\n  if (isName(\"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%tt\"), xmlTree)) {\n    var body = getNamedChildren(\"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%body\"), xmlTree)[0];\n\n    if (body) {\n      root.children.push(parseBody(root, body, null));\n    } else {\n      Logger.error(\"Couldn't find body element in the ttml document\");\n    }\n  }\n\n  return root;\n}\n\nfunction setAudioCacheStrategy(cacheStrategy) {\n  audioCacheStrategy = cacheStrategy;\n  Logger.log(\"Audio cache strategy set to \".concat(cacheStrategy === CACHE_STRATEGY_REUSE ? \"REUSE\" : \"NO CACHE\"));\n}\n\nfunction getAudioCacheStrategy() {\n  return audioCacheStrategy;\n}\n\n//# sourceURL=webpack://adhere-lib/./src/Parser.es6?");

/***/ }),

/***/ "./src/PlaybackProperties.es6":
/*!************************************!*\
  !*** ./src/PlaybackProperties.es6 ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar PlaybackPropertiesSingleton = /*#__PURE__*/function () {\n  function PlaybackPropertiesSingleton() {\n    var _this = this;\n\n    _classCallCheck(this, PlaybackPropertiesSingleton);\n\n    //console.log(\"Created instance\");\n    this.advolCallbacks = [];\n    this.advol = document.querySelector(\"#advol\");\n\n    this.advol.onchange = function () {\n      _this.advolCallbacks.forEach(function (callback) {\n        callback(_this.getCurrentGain());\n      });\n    };\n  } //Fetch UI gain value\n\n\n  _createClass(PlaybackPropertiesSingleton, [{\n    key: \"getCurrentGain\",\n    value: function getCurrentGain() {\n      //console.info(\"Call to get current gain\");\n      return parseFloat(this.advol.value);\n    } //Register function and return its index\n\n  }, {\n    key: \"registerCallback\",\n    value: function registerCallback(fn) {\n      return this.advolCallbacks.push(fn) - 1;\n    } //Deregister callback by index\n\n  }, {\n    key: \"deregisterCallback\",\n    value: function deregisterCallback(index) {\n      delete this.advolCallbacks[index];\n    }\n  }]);\n\n  return PlaybackPropertiesSingleton;\n}();\n\nvar PlaybackProperties = new PlaybackPropertiesSingleton();\nvar _default = PlaybackProperties;\nexports.default = _default;\n\n//# sourceURL=webpack://adhere-lib/./src/PlaybackProperties.es6?");

/***/ }),

/***/ "./src/SpeechSourceNode.es6":
/*!**********************************!*\
  !*** ./src/SpeechSourceNode.es6 ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\n\nvar _AdNode2 = _interopRequireDefault(__webpack_require__(/*! ./AdNode.es6 */ \"./src/AdNode.es6\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n// import Logger from \"./Logger.es6\";\nvar Logger = __webpack_require__(/*! ./Logger.es6 */ \"./src/Logger.es6\").Logger;\n/*eslint func-style: [\"error\", \"declaration\"]*/\n\n\nfunction speakToRate(str) {\n  var ret;\n\n  switch (str) {\n    case \"fast\":\n      ret = 1.5;\n      break;\n\n    case \"slow\":\n      ret = 0.66;\n      break;\n\n    case \"normal\":\n    default:\n      ret = 1;\n      break;\n  }\n\n  return ret;\n} //Convert to a value between 0 and 2, 1 being a standard pitch\n//What this output number means isn't clear, and probably up to the browser\n\n\nfunction pitchToValue(str) {\n  var ret = 1;\n\n  if (str) {\n    var pcIdx = str.indexOf(\"%\");\n\n    if (pcIdx >= 0) {\n      var pcstr = str.substring(0, pcIdx);\n      ret = parseFloat(pcstr) / 100 + 1;\n    }\n  }\n\n  return ret;\n}\n\nvar SpeechSourceNode = /*#__PURE__*/function (_AdNode) {\n  _inherits(SpeechSourceNode, _AdNode);\n\n  var _super = _createSuper(SpeechSourceNode);\n\n  function SpeechSourceNode(parent, xmlNode, audioContext) {\n    var _this;\n\n    _classCallCheck(this, SpeechSourceNode);\n\n    _this = _super.call(this, parent, xmlNode, audioContext);\n    _this.utter = new SpeechSynthesisUtterance();\n    _this.utter.text = _this.value;\n    _this.utter.lang = \"en-US\";\n    _this.utter.rate = speakToRate(_this.speak);\n    _this.utter.pitch = pitchToValue(_this.pitch);\n    return _this;\n  }\n\n  _createClass(SpeechSourceNode, [{\n    key: \"onActive\",\n    value: function onActive() {\n      _get(_getPrototypeOf(SpeechSourceNode.prototype), \"onActive\", this).call(this);\n\n      Logger.log(\"\".concat(this.name, \" active speak: \").concat(this.utter.text));\n      speechSynthesis.speak(this.utter);\n    }\n  }, {\n    key: \"onInactive\",\n    value: function onInactive() {\n      _get(_getPrototypeOf(SpeechSourceNode.prototype), \"onInactive\", this).call(this);\n\n      Logger.log(\"\".concat(this.name, \" inactive speak: \").concat(this.utter.text));\n      speechSynthesis.cancel(this.utter);\n    }\n  }, {\n    key: \"onPause\",\n    value: function onPause() {\n      speechSynthesis.pause();\n    }\n  }, {\n    key: \"onResume\",\n    value: function onResume() {\n      speechSynthesis.resume();\n    }\n  }]);\n\n  return SpeechSourceNode;\n}(_AdNode2[\"default\"]);\n\nexports.default = SpeechSourceNode;\n\n//# sourceURL=webpack://adhere-lib/./src/SpeechSourceNode.es6?");

/***/ }),

/***/ "./src/TextPresenter.es6":
/*!*******************************!*\
  !*** ./src/TextPresenter.es6 ***!
  \*******************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// Copyright 2019 British Broadcasting Corporation\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// import Logger from \"./Logger.es6\";\nvar Logger = __webpack_require__(/*! ./Logger.es6 */ \"./src/Logger.es6\").Logger;\n\nvar callbacks = [];\nvar presentedStrings = new Map();\nvar key = 1; // if you start with zero, the first one never leaves\n\n/*eslint no-console: [\"error\", { allow: [\"warn\", \"error\", \"log\", \"dir\"] }] */\n\nvar TextPresenter = /*#__PURE__*/function () {\n  function TextPresenter() {\n    _classCallCheck(this, TextPresenter);\n  }\n\n  _createClass(TextPresenter, null, [{\n    key: \"present\",\n    value: function present(str, source) {\n      var thisKey = key;\n      presentedStrings.set(thisKey, str);\n      key++;\n      Logger.log(\"TP: adding key \".concat(thisKey, \" from \").concat(source, \": \").concat(str));\n      this.updatePresentedText();\n      return thisKey;\n    }\n  }, {\n    key: \"unPresent\",\n    value: function unPresent(removeKey) {\n      // remove the text with the key\n      Logger.log(\"TP: removing value for key \".concat(removeKey));\n      presentedStrings[\"delete\"](removeKey);\n      this.updatePresentedText();\n    }\n  }, {\n    key: \"updatePresentedText\",\n    value: function updatePresentedText() {\n      var generatedString = \"\";\n      presentedStrings.forEach(function (v) {\n        generatedString = v; // change = to += to concatenate, or leave as is to just show the last one\n      });\n      callbacks.forEach(function (cb) {\n        return cb(generatedString);\n      });\n    }\n  }, {\n    key: \"addCallback\",\n    value: function addCallback(cb) {\n      callbacks.push(cb);\n    }\n  }]);\n\n  return TextPresenter;\n}();\n\nexports.default = TextPresenter;\nmodule.exports = exports = {\n  TextPresenter: TextPresenter\n};\n\n//# sourceURL=webpack://adhere-lib/./src/TextPresenter.es6?");

/***/ }),

/***/ "./src/TimingCalculator.es6":
/*!**********************************!*\
  !*** ./src/TimingCalculator.es6 ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// Copyright 2019 British Broadcasting Corporation\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/*eslint func-style: [\"error\", \"declaration\"]*/\nfunction nullOrUndefined(thing) {\n  return thing === undefined || thing === null;\n}\n\nfunction specified(thing) {\n  return !nullOrUndefined(thing);\n}\n\nvar TimingCalculator = /*#__PURE__*/function () {\n  function TimingCalculator() {\n    _classCallCheck(this, TimingCalculator);\n  }\n\n  _createClass(TimingCalculator, null, [{\n    key: \"parseTimeString\",\n    value: function parseTimeString(timeStr) {\n      var rgx = /(\\d{2,}):(\\d{2,}):(\\d{2}(?:\\.\\d*)?)/;\n      var groups = timeStr.match(rgx);\n      var hours = parseInt(groups[1]);\n      var mins = parseInt(groups[2]);\n      var secs = parseFloat(groups[3]);\n      var total = hours * 3600 + mins * 60 + secs;\n      return total;\n    }\n  }, {\n    key: \"parseSeconds\",\n    value: function parseSeconds(timeText) {\n      var lowerTimeText = timeText.toLowerCase();\n      var isSecondsString = lowerTimeText.charAt(timeText.length - 1) === \"s\";\n      return isSecondsString ? this.parseSecondText(timeText) : this.parseTimeString(timeText);\n    }\n  }, {\n    key: \"parseSecondText\",\n    value: function parseSecondText(timingText) {\n      var timing = String(timingText);\n      timing = timing.substring(0, timing.length - 1);\n      return parseFloat(timing);\n    }\n  }, {\n    key: \"computeBegin\",\n    value: function computeBegin(element) {\n      var parent = element.parent;\n      var syncbase = parent ? this.computeBegin(parent) : 0;\n      var beginAttr = element.attributes.begin;\n      var begin = beginAttr ? this.parseSeconds(beginAttr) : 0;\n      return syncbase + begin;\n    }\n  }, {\n    key: \"computeEnd\",\n    value: function computeEnd(element) {\n      var _this = this;\n\n      var seekUp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var end = this.getSpecifiedEnd(element, seekUp);\n\n      if (nullOrUndefined(end)) {\n        // now we have to get the biggest defined end from each child\n        var ends = [];\n        element.children.forEach(function (c) {\n          ends.push(_this.computeEnd(c, false));\n        });\n\n        if (!ends.includes(undefined) && ends.length > 0) {\n          end = Math.max.apply(Math, ends);\n        }\n      }\n\n      return end;\n    }\n  }, {\n    key: \"getSpecifiedEnd\",\n    value: function getSpecifiedEnd(element) {\n      var seekUp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var parentEnd;\n      var resultingSpecifiedEnd;\n      var parent = element.parent;\n\n      if (seekUp && parent) {\n        parentEnd = this.getSpecifiedEnd(parent);\n      }\n\n      var syncbase = parent ? this.computeBegin(parent) : 0;\n      var thisEnd = element.attributes.end ? this.parseSeconds(element.attributes.end) + syncbase : undefined;\n\n      if (specified(thisEnd)) {\n        if (specified(parentEnd)) {\n          resultingSpecifiedEnd = Math.min(thisEnd, parentEnd);\n        } else {\n          resultingSpecifiedEnd = thisEnd;\n        }\n      } else {\n        // we don't specify an end\n        resultingSpecifiedEnd = parentEnd;\n      }\n\n      return resultingSpecifiedEnd;\n    }\n  }]);\n\n  return TimingCalculator;\n}();\n\nexports.default = TimingCalculator;\n\n//# sourceURL=webpack://adhere-lib/./src/TimingCalculator.es6?");

/***/ }),

/***/ "./src/TrackAPIHelper.es6":
/*!********************************!*\
  !*** ./src/TrackAPIHelper.es6 ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// Copyright 2019 British Broadcasting Corporation\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar TrackAPIHelper = /*#__PURE__*/function () {\n  function TrackAPIHelper(videoPlayer) {\n    _classCallCheck(this, TrackAPIHelper);\n\n    this.video = videoPlayer;\n    this.track = videoPlayer.addTextTrack(\"metadata\");\n  }\n\n  _createClass(TrackAPIHelper, [{\n    key: \"addCue\",\n    value: function addCue(newCue) {\n      this.track.addCue(newCue);\n    }\n  }, {\n    key: \"removeCues\",\n    value: function removeCues() {\n      while (this.track.cues.length > 0) {\n        this.track.removeCue(this.track.cues[0]);\n      }\n    }\n  }]);\n\n  return TrackAPIHelper;\n}();\n\nexports.default = TrackAPIHelper;\n\n//# sourceURL=webpack://adhere-lib/./src/TrackAPIHelper.es6?");

/***/ }),

/***/ "./src/Utils.es6":
/*!***********************!*\
  !*** ./src/Utils.es6 ***!
  \***********************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// Copyright 2019 British Broadcasting Corporation\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar Utils = /*#__PURE__*/function () {\n  function Utils() {\n    _classCallCheck(this, Utils);\n  }\n\n  _createClass(Utils, null, [{\n    key: \"NS_XML_URI\",\n    get: function get() {\n      return \"http://www.w3.org/XML/1998/namespace\";\n    }\n  }, {\n    key: \"NS_TTML_URI\",\n    get: function get() {\n      return \"http://www.w3.org/ns/ttml\";\n    }\n  }, {\n    key: \"NS_TTML_PARAMETER_URI\",\n    get: function get() {\n      return \"http://www.w3.org/ns/ttml#parameter\";\n    }\n  }, {\n    key: \"NS_TTML_STYLING_URI\",\n    get: function get() {\n      return \"http://www.w3.org/ns/ttml#styling\";\n    }\n  }, {\n    key: \"NS_TTML_AUDIO_URI\",\n    get: function get() {\n      return \"http://www.w3.org/ns/ttml#audio\";\n    }\n  }, {\n    key: \"NS_TTML_METADATA_URI\",\n    get: function get() {\n      return \"http://www.w3.org/ns/ttml#metadata\";\n    }\n  }, {\n    key: \"NS_TTML_ISD_URI\",\n    get: function get() {\n      return \"http://www.w3.org/ns/ttml#isd\";\n    }\n  }, {\n    key: \"isUndefined\",\n    value: function isUndefined(element) {\n      return element === null || element === undefined || element.attributes === undefined || element.name === undefined;\n    }\n  }, {\n    key: \"isAudioType\",\n    value: function isAudioType(fullyQualifiedName) {\n      return fullyQualifiedName === \"\".concat(Utils.NS_TTML_URI, \"%%body\") || fullyQualifiedName === \"\".concat(Utils.NS_TTML_URI, \"%%div\") || fullyQualifiedName === \"\".concat(Utils.NS_TTML_URI, \"%%p\") || fullyQualifiedName === \"\".concat(Utils.NS_TTML_URI, \"%%span\") || fullyQualifiedName === \"\".concat(Utils.NS_TTML_URI, \"%%animate\") || fullyQualifiedName === \"\".concat(Utils.NS_TTML_URI, \"%%audio\") || fullyQualifiedName === \"\".concat(Utils.NS_TTML_URI, \"%%source\") || fullyQualifiedName === \"\".concat(Utils.NS_TTML_URI, \"%%data\") || fullyQualifiedName === \"\".concat(Utils.NS_TTML_URI, \"%%chunk\") || fullyQualifiedName === \"\";\n    }\n  }, {\n    key: \"hasAudioAttribute\",\n    value: function hasAudioAttribute(element) {\n      return this.getAttributeByFullyQualifiedName(element, \"\".concat(Utils.NS_TTML_URI, \"#audio%%gain\")) !== undefined || this.getAttributeByFullyQualifiedName(element, \"\".concat(Utils.NS_TTML_URI, \"#audio%%pan\")) !== undefined || this.getAttributeByFullyQualifiedName(element, \"\".concat(Utils.NS_TTML_URI, \"#audio%%pitch\")) !== undefined || this.getAttributeByFullyQualifiedName(element, \"\".concat(Utils.NS_TTML_URI, \"#audio%%speak\")) !== undefined;\n    }\n  }, {\n    key: \"isAudioElement\",\n    value: function isAudioElement(element) {\n      if (Utils.isUndefined(element)) {\n        return false;\n      }\n\n      var fullyQualifiedName = element.fullyQualifiedName;\n\n      if (fullyQualifiedName === \"\".concat(Utils.NS_TTML_URI, \"%%audio\") || fullyQualifiedName === \"\".concat(Utils.NS_TTML_URI, \"%%source\") || fullyQualifiedName === \"\".concat(Utils.NS_TTML_URI, \"%%data\") || fullyQualifiedName === \"\".concat(Utils.NS_TTML_URI, \"%%chunk\")) {\n        return true;\n      }\n\n      return Utils.isAudioType(fullyQualifiedName) && Utils.hasAudioAttribute(element);\n    }\n  }, {\n    key: \"gleanNamespaces\",\n    value: function gleanNamespaces(element) {\n      var namespaces = {\n        \"xml\": Utils.NS_XML_URI\n      };\n\n      for (var key in element.attributes) {\n        if (element.attributes.hasOwnProperty(key)) {\n          if (key === \"xmlns\") {\n            namespaces[\"default\"] = element.attributes[key];\n          } else if (key === \"xmlns:xml\" && element.attributes[key] !== Utils.NS_XML_URI) {\n            console.warn(\"Namespace xmlns:xml is reserved in XML and must not be bound to another namespace!\");\n            console.warn(\"\".concat(key, \"=\").concat(element.attributes[key], \" is ignored.\"));\n          } else if (key.startsWith(\"xmlns:\")) {\n            namespaces[key.split(\":\")[1]] = element.attributes[key];\n          } else continue;\n        }\n      }\n\n      return namespaces;\n    }\n  }, {\n    key: \"getFullyQualifiedName\",\n    value: function getFullyQualifiedName(element) {\n      if (element.name.includes(\":\")) {\n        var prefix = element.name.split(\":\")[0];\n        var suffix = element.name.split(\":\")[1];\n\n        if (element.namespaces.hasOwnProperty(prefix)) {\n          return \"\".concat(element.namespaces[prefix], \"%%\").concat(suffix);\n        } else {\n          console.warn(\"Cannot find the namespace for element \".concat(element.name, \". Make sure your TTML2 file is valid XML.\"));\n          return undefined;\n        }\n      }\n\n      return element.name === \"\" ? \"\" : \"\".concat(element.namespaces[\"default\"], \"%%\").concat(element.name);\n    }\n  }, {\n    key: \"getAttributeByFullyQualifiedName\",\n    value: function getAttributeByFullyQualifiedName(element, fullyQualifiedAttributeName) {\n      if (fullyQualifiedAttributeName.includes(\"%%\")) {\n        var namespaceURI = fullyQualifiedAttributeName.split(\"%%\")[0];\n        var name = fullyQualifiedAttributeName.split(\"%%\")[1];\n\n        if (namespaceURI === \"\" && element.attributes.hasOwnProperty(name)) {\n          return element.attributes[name];\n        }\n\n        for (var prefix in element.namespaces) {\n          if (namespaceURI === element.namespaces[prefix] && element.attributes.hasOwnProperty(\"\".concat(prefix, \":\").concat(name))) {\n            return element.attributes[\"\".concat(prefix, \":\").concat(name)];\n          }\n        }\n      }\n\n      return undefined;\n    }\n  }]);\n\n  return Utils;\n}();\n\nexports.default = Utils;\n\n//# sourceURL=webpack://adhere-lib/./src/Utils.es6?");

/***/ }),

/***/ "./src/VideoAudioHook.es6":
/*!********************************!*\
  !*** ./src/VideoAudioHook.es6 ***!
  \********************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\n\nvar _Utils = _interopRequireDefault(__webpack_require__(/*! ./Utils.es6 */ \"./src/Utils.es6\"));\n\nvar _TrackAPIHelper = _interopRequireDefault(__webpack_require__(/*! ./TrackAPIHelper.es6 */ \"./src/TrackAPIHelper.es6\"));\n\nvar _XMLReader = _interopRequireDefault(__webpack_require__(/*! ./XMLReader.es6 */ \"./src/XMLReader.es6\"));\n\nvar _Parser = _interopRequireWildcard(__webpack_require__(/*! ./Parser.es6 */ \"./src/Parser.es6\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// import Logger from \"./Logger.es6\";\nvar Logger = __webpack_require__(/*! ./Logger.es6 */ \"./src/Logger.es6\").Logger;\n\nvar VideoAudioHook = /*#__PURE__*/function () {\n  function VideoAudioHook(videoplayer) {\n    _classCallCheck(this, VideoAudioHook);\n\n    this.videoplayer = videoplayer;\n    this.Utils = _Utils[\"default\"];\n    this.TrackApi = _TrackAPIHelper[\"default\"];\n    this.XMLReader = _XMLReader[\"default\"];\n    this.FileReader = FileReader;\n    this.firstTime = true;\n    this.videoplayer.addEventListener(\"play\", this.onVideoPlay.bind(this));\n    this.videoplayer.addEventListener(\"pause\", this.onVideoPause.bind(this));\n  }\n\n  _createClass(VideoAudioHook, [{\n    key: \"setup\",\n    value: function setup() {\n      this.xmlReader = new this.XMLReader();\n      this.track = new this.TrackApi(this.videoplayer);\n    }\n  }, {\n    key: \"attachTTMLfromFile\",\n    value: function attachTTMLfromFile(ttmlFile) {\n      var _this = this;\n\n      var reader = new this.FileReader();\n\n      reader.onload = function () {\n        _this.parseTTML(ttmlFile, reader.result);\n      };\n\n      reader.readAsText(ttmlFile);\n    }\n  }, {\n    key: \"attachTTMLfromURL\",\n    value: function attachTTMLfromURL(ttmlURL) {\n      var _this2 = this;\n\n      fetch(ttmlURL).then(function (response) {\n        if (!response.ok) throw Error(response.statusText);\n        return response.text().then(function (text) {\n          _this2.parseTTML(ttmlURL, text);\n        });\n      });\n    }\n  }, {\n    key: \"getHttpTTML\",\n    value: function getHttpTTML(ttmlUrl) {\n      var xhr = new XMLHttpRequest();\n      xhr.open(\"GET\", ttmlUrl);\n      xhr.addEventListener(\"load\", this.onTTMLLoad.bind(this));\n      Logger.log(\"GET ttml at: \".concat(ttmlUrl));\n      xhr.send();\n    }\n  }, {\n    key: \"onTTMLLoad\",\n    value: function onTTMLLoad(e) {\n      this.parseTTML(e.target.responseURL, e.target.responseText);\n    }\n  }, {\n    key: \"parseTTML\",\n    value: function parseTTML(url, result) {\n      var media = this.videoplayer;\n      this.xmlReader.parseXML(result, function () {\n        return null;\n      }, this.setupTree.bind(this, media, url));\n    }\n  }, {\n    key: \"audioCacheStrategy\",\n    get: function get() {\n      return (0, _Parser.getAudioCacheStrategy)();\n    },\n    set: function set(cacheStrategy) {\n      (0, _Parser.setAudioCacheStrategy)(cacheStrategy);\n    }\n  }, {\n    key: \"setupTree\",\n    value: function setupTree(media, documentPath, xmlTree) {\n      var _this3 = this;\n\n      if (this.tree) {\n        this.resetTree();\n      } // Work around Webkit, which currently offers the prefixed version only\n\n\n      var AudioContext = window.AudioContext || window.webkitAudioContext;\n      var audioContext = this.tree ? this.tree.audioContext : new AudioContext();\n      this.tree = (0, _Parser[\"default\"])(audioContext, media, documentPath, xmlTree, this.tree);\n      var cues = [];\n      Logger.log(\"VideoAudioHook.setupTree media.duration = \".concat(media.duration));\n      this.tree.makeCueObjects(cues, media);\n      cues.forEach(function (c) {\n        _this3.track.addCue(c);\n      });\n\n      if (this.videoplayer.currentTime > 0) {\n        this.activateTree();\n        this.videoplayer.currentTime = 0;\n      }\n    } //For all nodes in the tree with a NaN beginning, activate them.\n    //We can't do this until play() - Else audio sources without bbegin will start on load\n\n  }, {\n    key: \"activateTree\",\n    value: function activateTree() {\n      this.tree.traverse(function (c) {\n        if (isNaN(c.begin)) {\n          c.onActive();\n        }\n      });\n    } //onFinalise() goes a little further than onInactive\n    //onInactive should be sufficient for audionode garbage collection, but it's not clear if it's the case\n    //Firefox webaudio tab shows audionodes persisting(actually though?) long after use and disconnection\n    //At the very least, we need to revokeObjectURL.\n\n  }, {\n    key: \"resetTree\",\n    value: function resetTree() {\n      this.track.removeCues();\n      this.tree.traverse(function (c) {\n        if (typeof c.onFinalise === \"function\") {\n          c.onFinalise();\n        }\n      });\n      this.tree.children = [];\n    }\n  }, {\n    key: \"onVideoPlay\",\n    value: function onVideoPlay() {\n      var _this4 = this;\n\n      var audioContext = this.tree.audioContext;\n\n      if (audioContext) {\n        Logger.log(\"resuming audio context\");\n        audioContext.resume().then(function () {\n          if (_this4.firstTime) {\n            _this4.activateTree();\n\n            _this4.firstTime = false;\n          } else {\n            _this4.tree.traverse(function (c) {\n              if (typeof c.onRestart === \"function\") {\n                c.onRestart();\n              }\n            });\n          }\n        });\n      }\n    }\n  }, {\n    key: \"onVideoPause\",\n    value: function onVideoPause() {\n      var _this5 = this;\n\n      var audioContext = this.tree.audioContext;\n\n      if (audioContext && audioContext.state === \"running\") {\n        Logger.log(\"suspending audio context\");\n        audioContext.suspend().then(function () {\n          _this5.tree.traverse(function (c) {\n            if (typeof c.onPause === \"function\") {\n              c.onPause();\n            }\n          });\n        });\n      }\n    }\n  }]);\n\n  return VideoAudioHook;\n}();\n\nexports.default = VideoAudioHook;\nmodule.exports = exports = {\n  VideoAudioHook: VideoAudioHook\n};\n\n//# sourceURL=webpack://adhere-lib/./src/VideoAudioHook.es6?");

/***/ }),

/***/ "./src/XMLReader.es6":
/*!***************************!*\
  !*** ./src/XMLReader.es6 ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\n\nvar _xmlReader = _interopRequireDefault(__webpack_require__(/*! xml-reader */ \"./node_modules/xml-reader/dist/reader.js\"));\n\nvar _xmlQuery = _interopRequireDefault(__webpack_require__(/*! xml-query */ \"./node_modules/xml-query/dist/index.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar XMLReader = /*#__PURE__*/function () {\n  function XMLReader() {\n    _classCallCheck(this, XMLReader);\n\n    this.xmlReader = _xmlReader[\"default\"].create();\n    this.xmlQuery = _xmlQuery[\"default\"];\n  }\n\n  _createClass(XMLReader, [{\n    key: \"parseXML\",\n    value: function parseXML(ttmlFile, processDiv, doneCB) {\n      this.xmlReader.reset();\n      this.xmlReader.once(\"done\", doneCB);\n      this.xmlReader.parse(ttmlFile);\n    }\n  }]);\n\n  return XMLReader;\n}();\n\nexports.default = XMLReader;\n\n//# sourceURL=webpack://adhere-lib/./src/XMLReader.es6?");

/***/ }),

/***/ "./src/index.es6":
/*!***********************!*\
  !*** ./src/index.es6 ***!
  \***********************/
/***/ ((module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nObject.defineProperty(exports, \"VideoAudioHook\", ({\n  enumerable: true,\n  get: function get() {\n    return _VideoAudioHook.VideoAudioHook;\n  }\n}));\nObject.defineProperty(exports, \"TextPresenter\", ({\n  enumerable: true,\n  get: function get() {\n    return _TextPresenter.TextPresenter;\n  }\n}));\nObject.defineProperty(exports, \"Logger\", ({\n  enumerable: true,\n  get: function get() {\n    return _Logger.Logger;\n  }\n}));\n\nvar _VideoAudioHook = __webpack_require__(/*! ./VideoAudioHook.es6 */ \"./src/VideoAudioHook.es6\");\n\nvar _TextPresenter = __webpack_require__(/*! ./TextPresenter.es6 */ \"./src/TextPresenter.es6\");\n\nvar _Logger = __webpack_require__(/*! ./Logger.es6 */ \"./src/Logger.es6\");\n\n// Copyright 2019 British Broadcasting Corporation\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nmodule.exports = exports = {\n  Logger: _Logger.Logger,\n  TextPresenter: _TextPresenter.TextPresenter,\n  VideoAudioHook: _VideoAudioHook.VideoAudioHook\n};\n\n//# sourceURL=webpack://adhere-lib/./src/index.es6?");

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack://adhere-lib/./node_modules/base64-js/index.js?");

/***/ }),

/***/ "./node_modules/eventemitter3/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eventemitter3/index.js ***!
  \*********************************************/
/***/ ((module) => {

eval("\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @api private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {Mixed} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @api private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @api public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @api public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {String|Symbol} event The event name.\n * @param {Boolean} exists Only check if there are listeners.\n * @returns {Array|Boolean}\n * @api public\n */\nEventEmitter.prototype.listeners = function listeners(event, exists) {\n  var evt = prefix ? prefix + event : event\n    , available = this._events[evt];\n\n  if (exists) return !!available;\n  if (!available) return [];\n  if (available.fn) return [available.fn];\n\n  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {\n    ee[i] = available[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {String|Symbol} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @api public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {String|Symbol} event The event name.\n * @param {Function} fn The listener function.\n * @param {Mixed} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @api public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  var listener = new EE(fn, context || this)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;\n  else if (!this._events[evt].fn) this._events[evt].push(listener);\n  else this._events[evt] = [this._events[evt], listener];\n\n  return this;\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {String|Symbol} event The event name.\n * @param {Function} fn The listener function.\n * @param {Mixed} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @api public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  var listener = new EE(fn, context || this, true)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;\n  else if (!this._events[evt].fn) this._events[evt].push(listener);\n  else this._events[evt] = [this._events[evt], listener];\n\n  return this;\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {String|Symbol} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {Mixed} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @api public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    if (--this._eventsCount === 0) this._events = new Events();\n    else delete this._events[evt];\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n         listeners.fn === fn\n      && (!once || listeners.once)\n      && (!context || listeners.context === context)\n    ) {\n      if (--this._eventsCount === 0) this._events = new Events();\n      else delete this._events[evt];\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n           listeners[i].fn !== fn\n        || (once && !listeners[i].once)\n        || (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else if (--this._eventsCount === 0) this._events = new Events();\n    else delete this._events[evt];\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {String|Symbol} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @api public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) {\n      if (--this._eventsCount === 0) this._events = new Events();\n      else delete this._events[evt];\n    }\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// This function doesn't apply anymore.\n//\nEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n  return this;\n};\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n\n\n//# sourceURL=webpack://adhere-lib/./node_modules/eventemitter3/index.js?");

/***/ }),

/***/ "./node_modules/xml-lexer/dist/lexer.js":
/*!**********************************************!*\
  !*** ./node_modules/xml-lexer/dist/lexer.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar EventEmitter = __webpack_require__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\");\nvar noop = function noop() {};\n\nvar State = {\n    data: 'state-data',\n    cdata: 'state-cdata',\n    tagBegin: 'state-tag-begin',\n    tagName: 'state-tag-name',\n    tagEnd: 'state-tag-end',\n    attributeNameStart: 'state-attribute-name-start',\n    attributeName: 'state-attribute-name',\n    attributeNameEnd: 'state-attribute-name-end',\n    attributeValueBegin: 'state-attribute-value-begin',\n    attributeValue: 'state-attribute-value'\n};\n\nvar Action = {\n    lt: 'action-lt',\n    gt: 'action-gt',\n    space: 'action-space',\n    equal: 'action-equal',\n    quote: 'action-quote',\n    slash: 'action-slash',\n    char: 'action-char',\n    error: 'action-error'\n};\n\nvar Type = {\n    text: 'text',\n    openTag: 'open-tag',\n    closeTag: 'close-tag',\n    attributeName: 'attribute-name',\n    attributeValue: 'attribute-value'\n};\n\nvar charToAction = {\n    ' ': Action.space,\n    '\\t': Action.space,\n    '\\n': Action.space,\n    '\\r': Action.space,\n    '<': Action.lt,\n    '>': Action.gt,\n    '\"': Action.quote,\n    \"'\": Action.quote,\n    '=': Action.equal,\n    '/': Action.slash\n};\n\nvar getAction = function getAction(char) {\n    return charToAction[char] || Action.char;\n};\n\n/**\n * @param  {Object} options\n * @param  {Boolean} options.debug\n * @return {Object}\n */\nvar create = function create(options) {\n    var _State$data, _State$tagBegin, _State$tagName, _State$tagEnd, _State$attributeNameS, _State$attributeName, _State$attributeNameE, _State$attributeValue, _State$attributeValue2, _lexer$stateMachine;\n\n    options = Object.assign({ debug: false }, options);\n    var lexer = new EventEmitter();\n    var state = State.data;\n    var data = '';\n    var tagName = '';\n    var attrName = '';\n    var attrValue = '';\n    var isClosing = '';\n    var openingQuote = '';\n\n    var emit = function emit(type, value) {\n        // for now, ignore tags like: '?xml', '!DOCTYPE' or comments\n        if (tagName[0] === '?' || tagName[0] === '!') {\n            return;\n        }\n        var event = { type: type, value: value };\n        if (options.debug) {\n            console.log('emit:', event);\n        }\n        lexer.emit('data', event);\n    };\n\n    lexer.stateMachine = (_lexer$stateMachine = {}, _defineProperty(_lexer$stateMachine, State.data, (_State$data = {}, _defineProperty(_State$data, Action.lt, function () {\n        if (data.trim()) {\n            emit(Type.text, data);\n        }\n        tagName = '';\n        isClosing = false;\n        state = State.tagBegin;\n    }), _defineProperty(_State$data, Action.char, function (char) {\n        data += char;\n    }), _State$data)), _defineProperty(_lexer$stateMachine, State.cdata, _defineProperty({}, Action.char, function (char) {\n        data += char;\n        if (data.substr(-3) === ']]>') {\n            emit(Type.text, data.slice(0, -3));\n            data = '';\n            state = State.data;\n        }\n    })), _defineProperty(_lexer$stateMachine, State.tagBegin, (_State$tagBegin = {}, _defineProperty(_State$tagBegin, Action.space, noop), _defineProperty(_State$tagBegin, Action.char, function (char) {\n        tagName = char;\n        state = State.tagName;\n    }), _defineProperty(_State$tagBegin, Action.slash, function () {\n        tagName = '';\n        isClosing = true;\n    }), _State$tagBegin)), _defineProperty(_lexer$stateMachine, State.tagName, (_State$tagName = {}, _defineProperty(_State$tagName, Action.space, function () {\n        if (isClosing) {\n            state = State.tagEnd;\n        } else {\n            state = State.attributeNameStart;\n            emit(Type.openTag, tagName);\n        }\n    }), _defineProperty(_State$tagName, Action.gt, function () {\n        if (isClosing) {\n            emit(Type.closeTag, tagName);\n        } else {\n            emit(Type.openTag, tagName);\n        }\n        data = '';\n        state = State.data;\n    }), _defineProperty(_State$tagName, Action.slash, function () {\n        state = State.tagEnd;\n        emit(Type.openTag, tagName);\n    }), _defineProperty(_State$tagName, Action.char, function (char) {\n        tagName += char;\n        if (tagName === '![CDATA[') {\n            state = State.cdata;\n            data = '';\n            tagName = '';\n        }\n    }), _State$tagName)), _defineProperty(_lexer$stateMachine, State.tagEnd, (_State$tagEnd = {}, _defineProperty(_State$tagEnd, Action.gt, function () {\n        emit(Type.closeTag, tagName);\n        data = '';\n        state = State.data;\n    }), _defineProperty(_State$tagEnd, Action.char, noop), _State$tagEnd)), _defineProperty(_lexer$stateMachine, State.attributeNameStart, (_State$attributeNameS = {}, _defineProperty(_State$attributeNameS, Action.char, function (char) {\n        attrName = char;\n        state = State.attributeName;\n    }), _defineProperty(_State$attributeNameS, Action.gt, function () {\n        data = '';\n        state = State.data;\n    }), _defineProperty(_State$attributeNameS, Action.space, noop), _defineProperty(_State$attributeNameS, Action.slash, function () {\n        isClosing = true;\n        state = State.tagEnd;\n    }), _State$attributeNameS)), _defineProperty(_lexer$stateMachine, State.attributeName, (_State$attributeName = {}, _defineProperty(_State$attributeName, Action.space, function () {\n        state = State.attributeNameEnd;\n    }), _defineProperty(_State$attributeName, Action.equal, function () {\n        emit(Type.attributeName, attrName);\n        state = State.attributeValueBegin;\n    }), _defineProperty(_State$attributeName, Action.gt, function () {\n        attrValue = '';\n        emit(Type.attributeName, attrName);\n        emit(Type.attributeValue, attrValue);\n        data = '';\n        state = State.data;\n    }), _defineProperty(_State$attributeName, Action.slash, function () {\n        isClosing = true;\n        attrValue = '';\n        emit(Type.attributeName, attrName);\n        emit(Type.attributeValue, attrValue);\n        state = State.tagEnd;\n    }), _defineProperty(_State$attributeName, Action.char, function (char) {\n        attrName += char;\n    }), _State$attributeName)), _defineProperty(_lexer$stateMachine, State.attributeNameEnd, (_State$attributeNameE = {}, _defineProperty(_State$attributeNameE, Action.space, noop), _defineProperty(_State$attributeNameE, Action.equal, function () {\n        emit(Type.attributeName, attrName);\n        state = State.attributeValueBegin;\n    }), _defineProperty(_State$attributeNameE, Action.gt, function () {\n        attrValue = '';\n        emit(Type.attributeName, attrName);\n        emit(Type.attributeValue, attrValue);\n        data = '';\n        state = State.data;\n    }), _defineProperty(_State$attributeNameE, Action.char, function (char) {\n        attrValue = '';\n        emit(Type.attributeName, attrName);\n        emit(Type.attributeValue, attrValue);\n        attrName = char;\n        state = State.attributeName;\n    }), _State$attributeNameE)), _defineProperty(_lexer$stateMachine, State.attributeValueBegin, (_State$attributeValue = {}, _defineProperty(_State$attributeValue, Action.space, noop), _defineProperty(_State$attributeValue, Action.quote, function (char) {\n        openingQuote = char;\n        attrValue = '';\n        state = State.attributeValue;\n    }), _defineProperty(_State$attributeValue, Action.gt, function () {\n        attrValue = '';\n        emit(Type.attributeValue, attrValue);\n        data = '';\n        state = State.data;\n    }), _defineProperty(_State$attributeValue, Action.char, function (char) {\n        openingQuote = '';\n        attrValue = char;\n        state = State.attributeValue;\n    }), _State$attributeValue)), _defineProperty(_lexer$stateMachine, State.attributeValue, (_State$attributeValue2 = {}, _defineProperty(_State$attributeValue2, Action.space, function (char) {\n        if (openingQuote) {\n            attrValue += char;\n        } else {\n            emit(Type.attributeValue, attrValue);\n            state = State.attributeNameStart;\n        }\n    }), _defineProperty(_State$attributeValue2, Action.quote, function (char) {\n        if (openingQuote === char) {\n            emit(Type.attributeValue, attrValue);\n            state = State.attributeNameStart;\n        } else {\n            attrValue += char;\n        }\n    }), _defineProperty(_State$attributeValue2, Action.gt, function (char) {\n        if (openingQuote) {\n            attrValue += char;\n        } else {\n            emit(Type.attributeValue, attrValue);\n            data = '';\n            state = State.data;\n        }\n    }), _defineProperty(_State$attributeValue2, Action.slash, function (char) {\n        if (openingQuote) {\n            attrValue += char;\n        } else {\n            emit(Type.attributeValue, attrValue);\n            isClosing = true;\n            state = State.tagEnd;\n        }\n    }), _defineProperty(_State$attributeValue2, Action.char, function (char) {\n        attrValue += char;\n    }), _State$attributeValue2)), _lexer$stateMachine);\n\n    var step = function step(char) {\n        if (options.debug) {\n            console.log(state, char);\n        }\n        var actions = lexer.stateMachine[state];\n        var action = actions[getAction(char)] || actions[Action.error] || actions[Action.char];\n        action(char);\n    };\n\n    lexer.write = function (str) {\n        var len = str.length;\n        for (var i = 0; i < len; i++) {\n            step(str[i]);\n        }\n    };\n\n    return lexer;\n};\n\nmodule.exports = {\n    State: State,\n    Action: Action,\n    Type: Type,\n    create: create\n};\n\n//# sourceURL=webpack://adhere-lib/./node_modules/xml-lexer/dist/lexer.js?");

/***/ }),

/***/ "./node_modules/xml-query/dist/index.js":
/*!**********************************************!*\
  !*** ./node_modules/xml-query/dist/index.js ***!
  \**********************************************/
/***/ ((module) => {

eval("\nvar flatMap = function (arr, fn) {\n    return Array.prototype.concat.apply([], arr.map(fn));\n};\nvar xmlQuery = function (ast) {\n    var nodes = Array.isArray(ast) ? ast : (ast ? [ast] : []);\n    var length = nodes.length;\n    var get = function (index) { return nodes[index]; };\n    var children = function () {\n        return xmlQuery(flatMap(nodes, function (node) { return node.children; }));\n    };\n    var findInNode = function (node, sel) {\n        var res = (node.name === sel) ? [node] : [];\n        return res.concat(flatMap(node.children, function (node) { return findInNode(node, sel); }));\n    };\n    var find = function (sel) {\n        return xmlQuery(flatMap(nodes, function (node) { return findInNode(node, sel); }));\n    };\n    var has = function (sel) {\n        if (nodes.length === 0) {\n            return false;\n        }\n        if (nodes.some(function (node) { return node.name === sel; })) {\n            return true;\n        }\n        return children().has(sel);\n    };\n    var attr = function (name) {\n        if (length) {\n            var attrs = nodes[0].attributes;\n            return name ? attrs[name] : attrs;\n        }\n    };\n    var eq = function (index) { return xmlQuery(nodes[index]); };\n    var first = function () { return eq(0); };\n    var last = function () { return eq(length - 1); };\n    var map = function (fn) { return nodes.map(fn); };\n    var each = function (fn) { return nodes.forEach(fn); };\n    var size = function () { return length; };\n    var prop = function (name) {\n        var node = get(0);\n        if (node) {\n            return node[name];\n        }\n    };\n    var text = function () {\n        var res = '';\n        each(function (node) {\n            if (node.type === 'text') {\n                res += node.value;\n            }\n            else {\n                res += xmlQuery(node).children().text();\n            }\n        });\n        return res;\n    };\n    return {\n        attr: attr,\n        children: children,\n        each: each,\n        eq: eq,\n        find: find,\n        has: has,\n        first: first,\n        get: get,\n        last: last,\n        length: length,\n        map: map,\n        prop: prop,\n        size: size,\n        text: text,\n        ast: ast,\n    };\n};\nmodule.exports = xmlQuery;\n\n\n//# sourceURL=webpack://adhere-lib/./node_modules/xml-query/dist/index.js?");

/***/ }),

/***/ "./node_modules/xml-reader/dist/reader.js":
/*!************************************************!*\
  !*** ./node_modules/xml-reader/dist/reader.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar EventEmitter = __webpack_require__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\");\nvar Lexer = __webpack_require__(/*! xml-lexer */ \"./node_modules/xml-lexer/dist/lexer.js\");\nvar Type = Lexer.Type;\n\nvar NodeType = {\n    element: 'element',\n    text: 'text'\n};\n\nvar createNode = function createNode(params) {\n    return Object.assign({\n        name: '',\n        type: NodeType.element,\n        value: '',\n        parent: null,\n        attributes: {},\n        children: []\n    }, params);\n};\n\nvar create = function create(options) {\n    options = Object.assign({\n        stream: false,\n        parentNodes: true,\n        doneEvent: 'done',\n        tagPrefix: 'tag:',\n        emitTopLevelOnly: false,\n        debug: false\n    }, options);\n\n    var lexer = void 0,\n        rootNode = void 0,\n        current = void 0,\n        attrName = void 0;\n\n    var reader = new EventEmitter();\n\n    var handleLexerData = function handleLexerData(data) {\n        switch (data.type) {\n\n            case Type.openTag:\n                if (current === null) {\n                    current = rootNode;\n                    current.name = data.value;\n                } else {\n                    var node = createNode({\n                        name: data.value,\n                        parent: current\n                    });\n                    current.children.push(node);\n                    current = node;\n                }\n                break;\n\n            case Type.closeTag:\n                var parent = current.parent;\n                if (!options.parentNodes) {\n                    current.parent = null;\n                }\n                if (current.name !== data.value) {\n                    // ignore unexpected closing tag\n                    break;\n                }\n                if (options.stream && parent === rootNode) {\n                    rootNode.children = [];\n                    // do not expose parent node in top level nodes\n                    current.parent = null;\n                }\n                if (!options.emitTopLevelOnly || parent === rootNode) {\n                    reader.emit(options.tagPrefix + current.name, current);\n                    reader.emit('tag', current.name, current);\n                }\n                if (current === rootNode) {\n                    // end of document, stop listening\n                    lexer.removeAllListeners('data');\n                    reader.emit(options.doneEvent, current);\n                    rootNode = null;\n                }\n                current = parent;\n                break;\n\n            case Type.text:\n                if (current) {\n                    current.children.push(createNode({\n                        type: NodeType.text,\n                        value: data.value,\n                        parent: options.parentNodes ? current : null\n                    }));\n                }\n                break;\n\n            case Type.attributeName:\n                attrName = data.value;\n                current.attributes[attrName] = '';\n                break;\n\n            case Type.attributeValue:\n                current.attributes[attrName] = data.value;\n                break;\n        }\n    };\n\n    reader.reset = function () {\n        lexer = Lexer.create({ debug: options.debug });\n        lexer.on('data', handleLexerData);\n        rootNode = createNode();\n        current = null;\n        attrName = '';\n        reader.parse = lexer.write;\n    };\n\n    reader.reset();\n    return reader;\n};\n\nvar parseSync = function parseSync(xml, options) {\n    options = Object.assign({}, options, { stream: false, tagPrefix: ':' });\n    var reader = create(options);\n    var res = void 0;\n    reader.on('done', function (ast) {\n        res = ast;\n    });\n    reader.parse(xml);\n    return res;\n};\n\nmodule.exports = {\n    parseSync: parseSync,\n    create: create,\n    NodeType: NodeType\n};\n\n//# sourceURL=webpack://adhere-lib/./node_modules/xml-reader/dist/reader.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.es6");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});