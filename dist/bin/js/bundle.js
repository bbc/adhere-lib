/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ var __webpack_modules__ = ({

/***/ "./src/AdLeafNode.es6":
/*!****************************!*\
  !*** ./src/AdLeafNode.es6 ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _AudioNub2 = _interopRequireDefault(__webpack_require__(/*! ./AudioNub.es6 */ \"./src/AudioNub.es6\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { \"default\": e }; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); } // Copyright 2019 British Broadcasting Corporation\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// import Logger from \"./Logger.es6\";\nvar Logger = (__webpack_require__(/*! ./Logger.es6 */ \"./src/Logger.es6\").Logger);\n// import TextPresenter from \"./TextPresenter.es6\";\nvar TextPresenter = (__webpack_require__(/*! ./TextPresenter.es6 */ \"./src/TextPresenter.es6\").TextPresenter);\nvar defaultOutput = null;\nvar AdLeafNode = exports[\"default\"] = /*#__PURE__*/function (_AudioNub) {\n  function AdLeafNode(parent, node, audioContext) {\n    var _this;\n    _classCallCheck(this, AdLeafNode);\n    _this = _callSuper(this, AdLeafNode, [parent, node, audioContext]);\n    if (!_this._name) {\n      _this._name = \"span (anonymous)\";\n    }\n    return _this;\n  }\n  _inherits(AdLeafNode, _AudioNub);\n  return _createClass(AdLeafNode, [{\n    key: \"makeDefaultOutput\",\n    value: function makeDefaultOutput() {\n      if (defaultOutput) {\n        defaultOutput.onInactive();\n      }\n      this.onActive();\n      defaultOutput = this;\n    }\n  }, {\n    key: \"onActive\",\n    value: function onActive() {\n      if (!this.isActive) {\n        this.output.connect(this.audioContext.destination);\n        if (defaultOutput && defaultOutput !== this) {\n          defaultOutput.onInactive();\n        }\n        Logger.log(\"Active leaf: \".concat(this.pathString));\n      }\n      _get(_getPrototypeOf(AdLeafNode.prototype), \"onActive\", this).call(this);\n      if (this.value) {\n        this.tpKey = TextPresenter.present(this.value, this.pathString);\n      }\n    }\n  }, {\n    key: \"onInactive\",\n    value: function onInactive() {\n      if (this.isActive) {\n        if (this.tpKey) {\n          TextPresenter.unPresent(this.tpKey);\n        }\n        this.output.disconnect(this.audioContext.destination);\n        if (defaultOutput && defaultOutput !== this) {\n          defaultOutput.onActive();\n        }\n        Logger.log(\"Inactive leaf: \".concat(this.pathString));\n      }\n      _get(_getPrototypeOf(AdLeafNode.prototype), \"onInactive\", this).call(this);\n    }\n  }]);\n}(_AudioNub2[\"default\"]);\n\n//# sourceURL=webpack://adhere-lib/./src/AdLeafNode.es6?");

/***/ }),

/***/ "./src/AdNode.es6":
/*!************************!*\
  !*** ./src/AdNode.es6 ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _Utils = _interopRequireDefault(__webpack_require__(/*! ./Utils.es6 */ \"./src/Utils.es6\"));\nvar _TimingCalculator = _interopRequireDefault(__webpack_require__(/*! ./TimingCalculator.es6 */ \"./src/TimingCalculator.es6\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { \"default\": e }; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); } // Copyright 2019 British Broadcasting Corporation\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//import Logger from \"./Logger.es6\";\nvar Logger = (__webpack_require__(/*! ./Logger.es6 */ \"./src/Logger.es6\").Logger);\nvar AdNode = exports[\"default\"] = /*#__PURE__*/function () {\n  function AdNode(parent, xmlNode, audioContext) {\n    _classCallCheck(this, AdNode);\n    this._xmlNode = xmlNode;\n    this.parent = parent;\n    this.time = {\n      begin: _TimingCalculator[\"default\"].computeBegin(xmlNode),\n      end: undefined\n    };\n    this._name = xmlNode.name;\n    this._value = xmlNode.value;\n    if (xmlNode.attributes) {\n      this._pitch = _Utils[\"default\"].getAttributeByFullyQualifiedName(xmlNode, \"\".concat(_Utils[\"default\"].NS_TTML_AUDIO_URI, \"%%pitch\"));\n      this._speak = _Utils[\"default\"].getAttributeByFullyQualifiedName(xmlNode, \"\".concat(_Utils[\"default\"].NS_TTML_AUDIO_URI, \"%%speak\"));\n      this._id = _Utils[\"default\"].getAttributeByFullyQualifiedName(xmlNode, \"\".concat(_Utils[\"default\"].NS_XML_URI, \"%%id\"));\n    }\n    if (audioContext) {\n      this.ac = audioContext;\n    }\n    // Logger.log(`Constructed an AdNode for ${this.pathString}, value \\\"${this.value}\\\"\n    // ${this.begin} --> ${this.end}`); // DEBUG\n  }\n  return _createClass(AdNode, [{\n    key: \"postComputeEnd\",\n    value: function postComputeEnd() {\n      this.time.end = _TimingCalculator[\"default\"].computeEnd(this._xmlNode);\n      // Logger.log(`postComputeEnd() for ${this.pathString}, value \\\"${this.value}\\\"\n      // ${this.begin} --> ${this.end}`); // DEBUG\n      if (this.children) {\n        this.children.forEach(function (c) {\n          c.postComputeEnd();\n        });\n      }\n    }\n  }, {\n    key: \"audioContext\",\n    get: function get() {\n      if (this.ac) {\n        return this.ac;\n      }\n      if (this.parent) {\n        return this.parent.audioContext;\n      }\n      return null;\n    }\n  }, {\n    key: \"begin\",\n    get: function get() {\n      var begin = NaN;\n      if (this.time) {\n        begin = this.time.begin;\n      }\n      return begin;\n    }\n  }, {\n    key: \"end\",\n    get: function get() {\n      var end = NaN;\n      if (this.time) {\n        end = this.time.end;\n      }\n      return end;\n    }\n  }, {\n    key: \"pitch\",\n    get: function get() {\n      if (this._pitch || this._pitch === 0) {\n        return this._pitch;\n      } else if (this.parent) {\n        return this.parent.pitch;\n      }\n      return undefined;\n    }\n  }, {\n    key: \"speak\",\n    get: function get() {\n      if (this._speak) {\n        return this._speak;\n      } else if (this.parent) {\n        return this.parent.speak;\n      }\n      return undefined;\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this._value;\n    }\n  }, {\n    key: \"videoMedia\",\n    get: function get() {\n      return this._videoMedia;\n    },\n    set: function set(vm) {\n      this._videoMedia = vm;\n    }\n  }, {\n    key: \"makeCueObjects\",\n    value: function makeCueObjects(arr, videoMedia) {\n      var _this = this;\n      this.videoMedia = videoMedia;\n      var b = this.begin;\n      var e = !isNaN(this.end) ? this.end : videoMedia.duration;\n      var v = this.value;\n      if (!isNaN(b) && !isNaN(e)) {\n        // Logger.log(`Making a cue for ${ this.pathString }, \\\"${ v }\\\",\n        // ${b} --> ${e}.`); // DEBUG\n        var newCue = new VTTCue(b, e, v);\n        newCue.onenter = function () {\n          return _this.onActive();\n        };\n        newCue.onexit = function () {\n          return _this.onInactive();\n        };\n        arr.push(newCue);\n        // } else {\n        //   Logger.log(`Not making a cue for ${ this.pathString }, \\\"${ v }\\\"\n        //   because b (${b}) or e (${e}) is NaN.`); // DEBUG\n      }\n      if (this.children) {\n        var _iterator = _createForOfIteratorHelper(this.children),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var c = _step.value;\n            c.makeCueObjects(arr, videoMedia);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n    }\n\n    //Go down the tree, apply fn(c) to all children\n  }, {\n    key: \"traverse\",\n    value: function traverse(fn) {\n      fn(this);\n      if (this.children) {\n        var _iterator2 = _createForOfIteratorHelper(this.children),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var c = _step2.value;\n            c.traverse(fn);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return this._name;\n    }\n  }, {\n    key: \"pathString\",\n    get: function get() {\n      return (this.parent ? \"\".concat(this.parent.pathString, \" -> \") : \"\") + \"\".concat(this.name).concat(this.idString);\n    }\n  }, {\n    key: \"idString\",\n    get: function get() {\n      return this._id ? \" id:\\\"\".concat(this._id, \"\\\"\") : \"\";\n    }\n  }, {\n    key: \"onActive\",\n    value: function onActive() {\n      this.isActive = true;\n      Logger.log(\"Active AdNode: \".concat(this.pathString));\n    }\n  }, {\n    key: \"onInactive\",\n    value: function onInactive() {\n      this.isActive = false;\n      Logger.log(\"Inactive AdNode: \".concat(this.pathString));\n    }\n  }, {\n    key: \"onFinalise\",\n    value: function onFinalise() {\n      if (this.isActive) {\n        this.onInactive();\n      }\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://adhere-lib/./src/AdNode.es6?");

/***/ }),

/***/ "./src/AdSourceNode.es6":
/*!******************************!*\
  !*** ./src/AdSourceNode.es6 ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _AudioNub2 = _interopRequireDefault(__webpack_require__(/*! ./AudioNub.es6 */ \"./src/AudioNub.es6\"));\nvar _TimingCalculator = _interopRequireDefault(__webpack_require__(/*! ./TimingCalculator.es6 */ \"./src/TimingCalculator.es6\"));\nvar _PlaybackProperties = _interopRequireDefault(__webpack_require__(/*! ./PlaybackProperties.es6 */ \"./src/PlaybackProperties.es6\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { \"default\": e }; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); } // Copyright 2019 British Broadcasting Corporation\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// import Logger from \"./Logger.es6\";\nvar Logger = (__webpack_require__(/*! ./Logger.es6 */ \"./src/Logger.es6\").Logger);\nvar readyStateMap = {\n  0: \"HAVE_NOTHING\",\n  1: \"HAVE_METADATA\",\n  2: \"HAVE_CURRENT_DATA\",\n  3: \"HAVE_FUTURE_DATA\",\n  4: \"HAVE_ENOUGH_DATA\"\n};\n\n// This guy is a little weird - It's the input to it's parent; i.e. in the graph\n// it is the parent, but in the tree (and xml), it's a child.\n// Don't use it for user controlled sources like video elements:\n// instead user AdUserControlledSourceNode for them.\nvar AdSourceNode = exports[\"default\"] = /*#__PURE__*/function (_AudioNub) {\n  function AdSourceNode(parent, xmlNode, audioContext, mediaPair) {\n    var _this;\n    _classCallCheck(this, AdSourceNode);\n    _this = _callSuper(this, AdSourceNode, [parent, xmlNode, audioContext]);\n    _this.mediaPair = mediaPair;\n    _this.media = mediaPair.media;\n    _this.mediaNode = mediaPair.mediaNode;\n    if (xmlNode.attributes.clipBegin) {\n      _this.clipBegin = _TimingCalculator[\"default\"].parseSeconds(xmlNode.attributes.clipBegin) || 0;\n    } else {\n      _this.clipBegin = 0;\n    }\n    if (xmlNode.attributes.clipEnd) {\n      _this.clipEnd = _TimingCalculator[\"default\"].parseSeconds(xmlNode.attributes.clipEnd) || NaN;\n    }\n    return _this;\n  }\n  _inherits(AdSourceNode, _AudioNub);\n  return _createClass(AdSourceNode, [{\n    key: \"mediaReadyState\",\n    value: function mediaReadyState(m) {\n      var readyState = m.readyState;\n      return readyStateMap[readyState];\n    }\n  }, {\n    key: \"addDebugEventHandlers\",\n    value: function addDebugEventHandlers() {\n      var _this2 = this;\n      var m = this.mediaPair.media;\n      if (m) {\n        m.addEventListener(\"abort\", function () {\n          Logger.log(\"Audio source aborted loading. readyState = \".concat(_this2.mediaReadyState(m)));\n        });\n        m.addEventListener(\"error\", function () {\n          Logger.log(\"Audio source error. readyState = \".concat(_this2.mediaReadyState(m)));\n        });\n        m.addEventListener(\"loadeddata\", function () {\n          Logger.log(\"Audio source loaded data. readyState = \".concat(_this2.mediaReadyState(m)));\n        });\n        m.addEventListener(\"loadstart\", function () {\n          Logger.log(\"Audio source loadstart. readyState = \".concat(_this2.mediaReadyState(m)));\n        });\n        m.addEventListener(\"playing\", function () {\n          Logger.log(\"Audio source is playing. readyState = \".concat(_this2.mediaReadyState(m)));\n        });\n        m.addEventListener(\"progress\", function () {\n          Logger.log(\"Audio source making progress. readyState = \".concat(_this2.mediaReadyState(m)));\n        });\n        m.addEventListener(\"waiting\", function () {\n          Logger.log(\"Audio source is waiting for more data. readyState = \".concat(_this2.mediaReadyState(m)));\n        });\n      }\n    }\n  }, {\n    key: \"end\",\n    get: function get() {\n      var ret;\n      var normalEnd = _get(_getPrototypeOf(AdSourceNode.prototype), \"end\", this);\n      if (this.clipEnd) {\n        //The duration of the clip added to the start time, or the span end, whichever comes first.\n        ret = Math.min(normalEnd, this.begin + (this.clipEnd - this.clipBegin));\n      } else {\n        ret = normalEnd;\n      }\n\n      // Logger.log(`AdSourceNode end() super said ${normalEnd} but I'm saying ${ret}`); // DEBUG\n      return ret;\n    }\n  }, {\n    key: \"onActive\",\n    value: function onActive() {\n      var _this3 = this;\n      if (this.mediaPair && !this.isActive) {\n        Logger.log(\"Active AdSourceNode: \".concat(this.pathString));\n        var offset = this.videoMedia.currentTime - this.begin;\n        this.media.currentTime = this.clipBegin ? this.clipBegin + offset : offset;\n        this.input = this.mediaNode;\n        this.gainNode.gain.value = this.gain * _PlaybackProperties[\"default\"].getCurrentGain();\n        this.input.connect(this.gainNode);\n        Logger.log(\"Connected to media element source with src= \".concat(this.input.mediaElement.currentSrc));\n        this.media.play()[\"catch\"](function (e) {\n          Logger.log(\"AdSourceNode play rejected with error: \".concat(e, \".\"));\n        });\n        this.output.connect(this.parent.gainNode); //TODO Make formal with .input\n        Logger.log(\"Active source into: \".concat(this.parent.name, \"; src: \").concat(this.media.src, \"; from: \").concat(this.media.currentTime, \" including offset of \").concat(offset, \".\"));\n        this.startTime = this.media.currentTime;\n        this.isActive = true;\n        this.gainId = _PlaybackProperties[\"default\"].registerCallback(function (uiGain) {\n          //const oldVal = this.gainNode.gain.value;\n          //console.info(\"Base gain\", this.gain, \"UI gain\", uiGain);\n          _this3.gainNode.gain.value = _this3.gain * uiGain;\n          //console.info(\"Final gain changes from\", oldVal, \"to\", this.gainNode.gain.value);\n        });\n      }\n    }\n  }, {\n    key: \"onInactive\",\n    value: function onInactive() {\n      if (this.media && this.isActive) {\n        Logger.log(\"Inactive AdSourceNode: \".concat(this.pathString));\n        this.media.pause();\n        this.input.disconnect(this.gainNode);\n        this.input = null;\n        this.output.disconnect(this.parent.gainNode);\n        Logger.log(\"Inactive source into: \".concat(this.parent.name, \"; src: \").concat(this.media.src));\n        this.endTime = this.media.currentTime;\n        // DEBUG: clipBegin/clipEnd\n        Logger.log( // eslint-disable-next-line max-len\n        \"ran source for: \".concat(this.endTime - this.startTime, \" clipBegin: \").concat(this.startTime, \" clipEnd: \").concat(this.endTime));\n        this.isActive = false;\n        _PlaybackProperties[\"default\"].deregisterCallback(this.gainId);\n      }\n    }\n  }, {\n    key: \"onPause\",\n    value: function onPause() {\n      if (this.media && this.isActive) {\n        this.media.pause();\n      }\n    }\n  }, {\n    key: \"onRestart\",\n    value: function onRestart() {\n      if (this.media && this.isActive) {\n        this.media.play();\n      }\n    }\n  }, {\n    key: \"onFinalise\",\n    value: function onFinalise() {\n      if (this.media) {\n        _get(_getPrototypeOf(AdSourceNode.prototype), \"onFinalise\", this).call(this);\n        var src = this.media.src;\n        if ((src + \"\").indexOf(\"blob://\") > 0) {\n          Logger.log(\"Clear audio src \" + this.media.src);\n          this.media.src = \"\";\n          URL.revokeObjectURL(src);\n        }\n        if (this.input) {\n          this.input.disconnect(this.gainNode);\n        }\n      }\n    }\n  }]);\n}(_AudioNub2[\"default\"]);\n\n//# sourceURL=webpack://adhere-lib/./src/AdSourceNode.es6?");

/***/ }),

/***/ "./src/AdUserControlledSourceNode.es6":
/*!********************************************!*\
  !*** ./src/AdUserControlledSourceNode.es6 ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _AdSourceNode2 = _interopRequireDefault(__webpack_require__(/*! ./AdSourceNode.es6 */ \"./src/AdSourceNode.es6\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { \"default\": e }; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); } // Copyright 2020 British Broadcasting Corporation\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// import Logger from \"./Logger.es6\";\nvar Logger = (__webpack_require__(/*! ./Logger.es6 */ \"./src/Logger.es6\").Logger);\n\n// This guy is a little weird - It's the input to it's parent; i.e. in the graph\n// it is the parent, but in the tree (and xml), it's a child.\n// This subclass is for user controlled sources like <video> elements, as\n// opposed to sources generated by the TTML source document.\nvar AdUserControlledSourceNode = exports[\"default\"] = /*#__PURE__*/function (_AdSourceNode) {\n  function AdUserControlledSourceNode(parent, xmlNode, audioContext, media) {\n    _classCallCheck(this, AdUserControlledSourceNode);\n    return _callSuper(this, AdUserControlledSourceNode, [parent, xmlNode, audioContext, media]);\n  }\n  _inherits(AdUserControlledSourceNode, _AdSourceNode);\n  return _createClass(AdUserControlledSourceNode, [{\n    key: \"onActive\",\n    value: function onActive() {\n      if (this.media && !this.isActive) {\n        this.input = this.mediaNode;\n        this.input.connect(this.gainNode);\n        Logger.log(\"Connected to media element source with src= \".concat(this.input.mediaElement.currentSrc));\n        if (this.parent) {\n          this.output.connect(this.parent.gainNode); //TODO Make formal with .input\n          Logger.log(\"Active source into: \".concat(this.parent.name, \"; src: \").concat(this.media.src, \"; from: \").concat(this.media.currentTime));\n        } else {\n          Logger.log(\"No parent to connect\");\n        }\n        this.startTime = this.media.currentTime;\n        this.isActive = true;\n      }\n    }\n  }, {\n    key: \"onInactive\",\n    value: function onInactive() {\n      if (this.media && this.isActive) {\n        this.input.disconnect(this.gainNode);\n        this.input = null;\n        if (this.parent) {\n          this.output.disconnect(this.parent.gainNode);\n          Logger.log(\"Inactive source into: \".concat(this.parent.name, \"; src: \").concat(this.media.src));\n        } else {\n          Logger.log(\"No parent to disconnect\");\n        }\n        this.endTime = this.media.currentTime;\n        this.isActive = false;\n      }\n    }\n  }, {\n    key: \"onPause\",\n    value: function onPause() {}\n  }, {\n    key: \"onRestart\",\n    value: function onRestart() {}\n  }, {\n    key: \"onFinalise\",\n    value: function onFinalise() {}\n  }]);\n}(_AdSourceNode2[\"default\"]);\n\n//# sourceURL=webpack://adhere-lib/./src/AdUserControlledSourceNode.es6?");

/***/ }),

/***/ "./src/AnimateNode.es6":
/*!*****************************!*\
  !*** ./src/AnimateNode.es6 ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _AdNode2 = _interopRequireDefault(__webpack_require__(/*! ./AdNode.es6 */ \"./src/AdNode.es6\"));\nvar _Utils = _interopRequireDefault(__webpack_require__(/*! ./Utils.es6 */ \"./src/Utils.es6\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { \"default\": e }; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); } // Copyright 2019 British Broadcasting Corporation\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// import Logger from \"./Logger.es6\";\nvar Logger = (__webpack_require__(/*! ./Logger.es6 */ \"./src/Logger.es6\").Logger);\nvar AnimateNode = exports[\"default\"] = /*#__PURE__*/function (_AdNode) {\n  function AnimateNode(parent, xmlNode, audioContext) {\n    var _this;\n    _classCallCheck(this, AnimateNode);\n    _this = _callSuper(this, AnimateNode, [parent, xmlNode, audioContext]);\n    if (_Utils[\"default\"].getAttributeByFullyQualifiedName(xmlNode, \"\".concat(_Utils[\"default\"].NS_TTML_AUDIO_URI, \"%%gain\"))) {\n      _this.gains = _Utils[\"default\"].getAttributeByFullyQualifiedName(xmlNode, \"\".concat(_Utils[\"default\"].NS_TTML_AUDIO_URI, \"%%gain\")).split(\";\").map(parseFloat);\n    }\n    if (_Utils[\"default\"].getAttributeByFullyQualifiedName(xmlNode, \"\".concat(_Utils[\"default\"].NS_TTML_AUDIO_URI, \"%%pan\"))) {\n      _this.pans = _Utils[\"default\"].getAttributeByFullyQualifiedName(xmlNode, \"\".concat(_Utils[\"default\"].NS_TTML_AUDIO_URI, \"%%pan\")).split(\";\").map(parseFloat);\n    }\n    return _this;\n  }\n  _inherits(AnimateNode, _AdNode);\n  return _createClass(AnimateNode, [{\n    key: \"onActive\",\n    value: function onActive() {\n      _get(_getPrototypeOf(AnimateNode.prototype), \"onActive\", this).call(this);\n      var duration = this.end - this.begin;\n      if (this.gains && this.gains.length > 0) {\n        this.parent.gainNode.gain.setValueCurveAtTime(Float32Array.from(this.gains), this.audioContext.currentTime, duration);\n        Logger.log( // eslint-disable-next-line max-len\n        \"Active animate node into: \".concat(this.parent.name, \"; gain: \").concat(this.gains.join(\", \"), \"; dur: \").concat(duration));\n      }\n      if (this.pans && this.pans.length > 0) {\n        // Try to work around older spec support in Webkit, noting that\n        // the PannerNode interface does not use AudioParam and therefore\n        // the attempt to use setValueCurveAtTime fails.\n        var panPosition = this.parent.panNode.pan || this.parent.panNode.position;\n        panPosition.setValueCurveAtTime(Float32Array.from(this.pans), this.audioContext.currentTime, duration);\n        Logger.log( // eslint-disable-next-line max-len\n        \"Active animate node into: \".concat(this.parent.name, \"; pan: \").concat(this.pans.join(\", \"), \"; dur: \").concat(duration));\n      }\n    }\n  }, {\n    key: \"onInactive\",\n    value: function onInactive() {\n      _get(_getPrototypeOf(AnimateNode.prototype), \"onInactive\", this).call(this);\n    }\n  }]);\n}(_AdNode2[\"default\"]);\n\n//# sourceURL=webpack://adhere-lib/./src/AnimateNode.es6?");

/***/ }),

/***/ "./src/AudioNub.es6":
/*!**************************!*\
  !*** ./src/AudioNub.es6 ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _AdNode2 = _interopRequireDefault(__webpack_require__(/*! ./AdNode.es6 */ \"./src/AdNode.es6\"));\nvar _Utils = _interopRequireDefault(__webpack_require__(/*! ./Utils.es6 */ \"./src/Utils.es6\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { \"default\": e }; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); } // Copyright 2019 British Broadcasting Corporation\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar AudioNub = exports[\"default\"] = /*#__PURE__*/function (_AdNode) {\n  function AudioNub(parent, xmlNode, audioContext) {\n    var _this;\n    _classCallCheck(this, AudioNub);\n    _this = _callSuper(this, AudioNub, [parent, xmlNode, audioContext]);\n    _this.copyAudioAttributes(xmlNode);\n    _this.createAudioNodes();\n    return _this;\n  }\n  _inherits(AudioNub, _AdNode);\n  return _createClass(AudioNub, [{\n    key: \"createAudioNodes\",\n    value: function createAudioNodes() {\n      this.gainNode = this.audioContext.createGain();\n\n      // Check that StereoPanner is supported. Webkit currently only\n      // supports the older interface's Panner.\n      var supportsStereoPanner = this.audioContext.createStereoPanner;\n      var supportsPanner = this.audioContext.createPanner;\n      if (supportsStereoPanner) {\n        this.panNode = this.audioContext.createStereoPanner();\n      } else if (supportsPanner) {\n        this.panNode = this.audioContext.createPanner();\n      }\n      this.gainNode.connect(this.panNode);\n      this.output = this.panNode;\n      if (supportsStereoPanner) {\n        this.panNode.pan.value = this.pan;\n      } else if (supportsPanner) {\n        this.panNode.position = 90 * this.pan;\n      }\n      this.gainNode.gain.value = this.gain;\n    }\n  }, {\n    key: \"onActive\",\n    value: function onActive() {\n      if (this.parent && !this.isActive) {\n        this.parent.output.connect(this.gainNode);\n      }\n      _get(_getPrototypeOf(AudioNub.prototype), \"onActive\", this).call(this);\n    }\n  }, {\n    key: \"onInactive\",\n    value: function onInactive() {\n      if (this.parent && this.isActive) {\n        this.parent.output.disconnect(this.gainNode);\n      }\n      _get(_getPrototypeOf(AudioNub.prototype), \"onInactive\", this).call(this);\n    }\n  }, {\n    key: \"onFinalise\",\n    value: function onFinalise() {\n      _get(_getPrototypeOf(AudioNub.prototype), \"onFinalise\", this).call(this);\n      this.gainNode.disconnect(this.panNode);\n    }\n  }, {\n    key: \"gain\",\n    get: function get() {\n      return !isNaN(this._gain) ? this._gain : 1;\n    }\n  }, {\n    key: \"pan\",\n    get: function get() {\n      return !isNaN(this._pan) ? this._pan : 0;\n    }\n  }, {\n    key: \"copyAudioAttributes\",\n    value: function copyAudioAttributes(xmlNode) {\n      if (xmlNode.attributes) {\n        this._gain = parseFloat(_Utils[\"default\"].getAttributeByFullyQualifiedName(xmlNode, \"\".concat(_Utils[\"default\"].NS_TTML_AUDIO_URI, \"%%gain\")));\n        this._pan = parseFloat(_Utils[\"default\"].getAttributeByFullyQualifiedName(xmlNode, \"\".concat(_Utils[\"default\"].NS_TTML_AUDIO_URI, \"%%pan\")));\n      }\n    }\n  }]);\n}(_AdNode2[\"default\"]);\n\n//# sourceURL=webpack://adhere-lib/./src/AudioNub.es6?");

/***/ }),

/***/ "./src/Logger.es6":
/*!************************!*\
  !*** ./src/Logger.es6 ***!
  \************************/
/***/ ((module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = exports.Logger = void 0;\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// Copyright 2019 British Broadcasting Corporation\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar callbacks = [];\nvar consoleEnabled = false;\nvar callbacksEnabled = true;\nvar videoplayer;\n/*eslint no-console: [\"error\", { allow: [\"warn\", \"error\", \"log\", \"dir\"] }] */\nvar Logger = exports.Logger = exports[\"default\"] = /*#__PURE__*/function () {\n  function Logger() {\n    _classCallCheck(this, Logger);\n  }\n  return _createClass(Logger, null, [{\n    key: \"log\",\n    value: function log(str) {\n      if (videoplayer) {\n        str = \"\".concat(videoplayer.currentTime.toFixed(3).padStart(8, \" \"), \" \").concat(str);\n      }\n      if (consoleEnabled) {\n        console.log(str);\n      }\n      if (callbacksEnabled) {\n        callbacks.forEach(function (cb) {\n          return cb(str);\n        });\n      }\n    }\n  }, {\n    key: \"addCallback\",\n    value: function addCallback(cb) {\n      callbacks.push(cb);\n    }\n  }, {\n    key: \"enableBrowserLogging\",\n    value: function enableBrowserLogging(value) {\n      consoleEnabled = value;\n    }\n  }, {\n    key: \"error\",\n    value: function error(str) {\n      if (consoleEnabled) {\n        console.error(str);\n      }\n      if (callbacksEnabled) {\n        callbacks.forEach(function (cb) {\n          return cb(str);\n        });\n      }\n    }\n  }, {\n    key: \"enableCallbacks\",\n    value: function enableCallbacks(value) {\n      if (consoleEnabled) {\n        console.log(\"Setting consoleEnabled to \".concat(value, \".\"));\n      }\n      callbacksEnabled = value;\n    }\n  }, {\n    key: \"setVideoPlayer\",\n    value: function setVideoPlayer(player) {\n      videoplayer = player;\n      if (videoplayer) {\n        this.log(\"Videoplayer set, log lines will be prefixed with video player currentTime.\");\n      } else {\n        this.log(\"Videoplayer unset, log lines will not have a timestamp.\");\n      }\n    }\n  }]);\n}();\nmodule.exports = exports = {\n  Logger: Logger\n};\n\n//# sourceURL=webpack://adhere-lib/./src/Logger.es6?");

/***/ }),

/***/ "./src/Parser.es6":
/*!************************!*\
  !*** ./src/Parser.es6 ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = parseTree;\nexports.getAudioCacheStrategy = getAudioCacheStrategy;\nexports.setAudioCacheStrategy = setAudioCacheStrategy;\nvar _Utils = _interopRequireDefault(__webpack_require__(/*! ./Utils.es6 */ \"./src/Utils.es6\"));\nvar _AdSourceNode = _interopRequireDefault(__webpack_require__(/*! ./AdSourceNode.es6 */ \"./src/AdSourceNode.es6\"));\nvar _AdLeafNode = _interopRequireDefault(__webpack_require__(/*! ./AdLeafNode.es6 */ \"./src/AdLeafNode.es6\"));\nvar _AdUserControlledSourceNode = _interopRequireDefault(__webpack_require__(/*! ./AdUserControlledSourceNode.es6 */ \"./src/AdUserControlledSourceNode.es6\"));\nvar _SpeechSourceNode = _interopRequireDefault(__webpack_require__(/*! ./SpeechSourceNode.es6 */ \"./src/SpeechSourceNode.es6\"));\nvar _AudioNub = _interopRequireDefault(__webpack_require__(/*! ./AudioNub.es6 */ \"./src/AudioNub.es6\"));\nvar _AnimateNode = _interopRequireDefault(__webpack_require__(/*! ./AnimateNode.es6 */ \"./src/AnimateNode.es6\"));\nvar _base64Js = _interopRequireDefault(__webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { \"default\": e }; }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; } // Copyright 2019 British Broadcasting Corporation\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// import Logger from \"./Logger.es6\";\nvar Logger = (__webpack_require__(/*! ./Logger.es6 */ \"./src/Logger.es6\").Logger);\nvar CACHE_STRATEGY_REUSE = true;\nvar CACHE_STRATEGY_NOCACHE = false;\nvar currentUrl = \"\";\nvar audioElements = {};\nvar audioResources = {};\nvar trackPrefix = \";track=\";\nvar defaultVideoGain = 1;\nvar audioCacheStrategy = CACHE_STRATEGY_NOCACHE;\n\n/*eslint func-style: [\"error\", \"declaration\"]*/\n/*eslint no-use-before-define: [\"error\", { \"functions\": false }]*/\n/*eslint max-statements: [\"error\", 25]*/\n\nfunction isName(fullyQualifiedName, node) {\n  return node.fullyQualifiedName === fullyQualifiedName;\n}\nfunction getNamedChildren(fullyQualifiedName, node) {\n  return node.children.filter(isName.bind(null, fullyQualifiedName));\n}\n\n//For an audio with a <source> element, make a mediaSrc url from the base64.\nfunction parseEmbeddedSource(node) {\n  var source = getNamedChildren(\"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%source\"), node)[0];\n  var data = getNamedChildren(\"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%data\"), source)[0];\n  var dataType = data.attributes.type;\n  var chunks = getNamedChildren(\"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%chunk\"), data);\n  var chunk = chunks[0]; //TODO: merge multiple chunks\n  if (chunk.children.length > 0) {\n    chunk.value = chunk.children[0].value;\n  }\n  var wsRegex = /\\s/gi;\n\n  // eslint-disable-next-line no-undef\n  var dataChunk = _base64Js[\"default\"].toByteArray(chunk.value.replace(wsRegex, \"\"));\n  var blob = new Blob([dataChunk], {\n    type: dataType\n  });\n  return URL.createObjectURL(blob);\n}\nfunction grabAudioResources(headNode) {\n  var ret = {};\n  var resources = getNamedChildren(\"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%resources\"), headNode)[0];\n  if (resources) {\n    var audios = getNamedChildren(\"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%audio\"), resources);\n    var _iterator = _createForOfIteratorHelper(audios),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var a = _step.value;\n        var id = _Utils[\"default\"].getAttributeByFullyQualifiedName(a, \"\".concat(_Utils[\"default\"].NS_XML_URI, \"%%id\"));\n        if (id) {\n          audioResources[id] = parseEmbeddedSource(a);\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  return ret;\n}\nfunction getAudioElement(audioSrc, audioContext) {\n  if (audioCacheStrategy === CACHE_STRATEGY_REUSE && audioSrc in audioElements) {\n    // Yay reuse this one\n    return audioElements[audioSrc];\n  }\n\n  // Need to make one\n  var media = new Audio();\n  media.onError = function () {\n    Logger.error(\"Error \".concat(media.error.code, \"; details: \").concat(media.error.message));\n  };\n  media.src = audioSrc;\n  media.preload = \"metadata\";\n  var node = audioContext.createMediaElementSource(media);\n  var pair = {\n    media: media,\n    mediaNode: node\n  };\n  if (audioCacheStrategy === CACHE_STRATEGY_REUSE) {\n    audioElements[audioSrc] = pair;\n  }\n  return pair;\n}\nfunction propagateNamespaces(xmlNode) {\n  if (xmlNode.parent === null) {\n    xmlNode.namespaces = _Utils[\"default\"].gleanNamespaces(xmlNode);\n    xmlNode.fullyQualifiedName = _Utils[\"default\"].getFullyQualifiedName(xmlNode);\n  }\n  if (xmlNode.children) {\n    var _iterator2 = _createForOfIteratorHelper(xmlNode.children),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var c = _step2.value;\n        if (c.parent === null || c.parent.namespaces === null || Object.keys(c.parent.namespaces).length === 0) {\n          c.namespaces = _Utils[\"default\"].gleanNamespaces(c);\n        } else {\n          c.namespaces = Object.assign(c.parent.namespaces, _Utils[\"default\"].gleanNamespaces(c));\n        }\n        c.fullyQualifiedName = _Utils[\"default\"].getFullyQualifiedName(c);\n        propagateNamespaces(c);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n}\n\n//The xml parser makes anonymous spans under real spans, let's flatten the two together.\nfunction flattenSpans(xmlNode) {\n  if (xmlNode.children) {\n    for (var i = 0; i < xmlNode.children.length;) {\n      var c = xmlNode.children[i];\n      if ((xmlNode.fullyQualifiedName === \"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%span\") || xmlNode.fullyQualifiedName === \"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%chunk\")) && c.fullyQualifiedName === \"\") {\n        xmlNode.value = c.value; //Take the text inside it\n        xmlNode.children.splice(i, 1);\n      } else {\n        flattenSpans(c);\n        i++;\n      }\n    }\n  }\n}\n\n//remove any nodes that don't fall under the isAudioType definition\n//clear out the unrelated ttml stuff\nfunction removeOther(xmlNode) {\n  if (xmlNode.children) {\n    for (var i = 0; i < xmlNode.children.length;) {\n      var c = xmlNode.children[i];\n      if (!_Utils[\"default\"].isAudioType(c.fullyQualifiedName)) {\n        xmlNode.children.splice(i, 1);\n      } else {\n        removeOther(c);\n        i++;\n      }\n    }\n  }\n}\nfunction siblingsHaveAudio(xmlNode) {\n  var siblings = xmlNode.parent.children;\n  var _iterator3 = _createForOfIteratorHelper(siblings),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var s = _step3.value;\n      // eslint-disable-next-line eqeqeq\n      if (s != xmlNode && s.fullyQualifiedName === \"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%audio\")) {\n        return true;\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  return false;\n}\nfunction markAudio(xmlNode) {\n  if (xmlNode.parent) {\n    xmlNode.hasAudio = xmlNode.parent.hasAudio;\n  }\n  if (_Utils[\"default\"].isAudioElement(xmlNode) || (xmlNode.fullyQualifiedName === \"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%p\") || xmlNode.fullyQualifiedName === \"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%div\") || xmlNode.fullyQualifiedName === \"\" || xmlNode.fullyQualifiedName === \"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%span\")) && siblingsHaveAudio(xmlNode)) {\n    xmlNode.hasAudio = true;\n  }\n  if (xmlNode.children) {\n    var _iterator4 = _createForOfIteratorHelper(xmlNode.children),\n      _step4;\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var c = _step4.value;\n        markAudio(c);\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n    xmlNode.hasAudio = xmlNode.hasAudio || xmlNode.children.some(function (c) {\n      return c.hasAudio;\n    });\n  }\n}\nfunction markSpeech(xmlNode, parentSpeech) {\n  var speechSpecified = false;\n  if (xmlNode.attributes) {\n    var speakAttribute = _Utils[\"default\"].getAttributeByFullyQualifiedName(xmlNode, \"\".concat(_Utils[\"default\"].NS_TTML_AUDIO_URI, \"%%speak\"));\n    if (speakAttribute) {\n      speechSpecified = true;\n      xmlNode.hasSpeech = !(speakAttribute === \"none\");\n    }\n  }\n  if (!speechSpecified) {\n    // it's inherited downwards, if I don't specify, I get what my parent specifies.\n    xmlNode.hasSpeech = parentSpeech;\n  }\n  if (xmlNode.children) {\n    var hasSpeech = xmlNode.hasSpeech;\n    var _iterator5 = _createForOfIteratorHelper(xmlNode.children),\n      _step5;\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var c = _step5.value;\n        var thisChildHasSpeech = markSpeech(c, hasSpeech);\n        xmlNode.hasSpeech = thisChildHasSpeech || xmlNode.hasSpeech; //If any children have speech, I have speech (but that doesn't mean all my children do)\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n  }\n  return xmlNode.hasSpeech;\n}\nfunction removeNotAudio(xmlNode) {\n  //Remove anythin without .hasAudio or .hasSpeech.\n  if (xmlNode.children) {\n    for (var i = 0; i < xmlNode.children.length;) {\n      var c = xmlNode.children[i];\n      if (c.hasAudio || c.hasSpeech) {\n        removeNotAudio(c);\n        i++;\n      } else {\n        xmlNode.children.splice(i, 1);\n      }\n    }\n  }\n}\nfunction prepareXML(xmlNode) {\n  propagateNamespaces(xmlNode);\n  flattenSpans(xmlNode);\n  removeOther(xmlNode);\n\n  //Mark nodes for hasSpeech and hasAudio\n  //Basically am I used in the pathway; if I or my descendants or my ascendants\n  //have speech or audio attributes, I'm marked too.\n  markAudio(xmlNode);\n  markSpeech(xmlNode);\n  removeNotAudio(xmlNode);\n}\nfunction parseAnimateNode(parent, node, audioContext) {\n  var ret = new _AnimateNode[\"default\"](parent, node, audioContext);\n  return ret;\n}\nfunction isLeafNode(node) {\n  return node.fullyQualifiedName === \"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%span\") || node.fullyQualifiedName === \"\"; //span or anonymous span/\n}\nfunction parseSpeechNode(parent, node, audioContext) {\n  var ret = new _SpeechSourceNode[\"default\"](parent, node, audioContext);\n  return ret;\n}\nfunction parseAudioSourceNode(parent, node) {\n  var src = node.attributes.src;\n  if (src && src.indexOf(trackPrefix) >= 0) {\n    //Ignore body level track specifiers.\n    return undefined;\n  }\n  var audioSrc;\n  if (src) {\n    if (src.indexOf(\"#\") === 0) {\n      audioSrc = audioResources[src.substring(1)];\n    } else {\n      audioSrc = currentUrl + src;\n    }\n  } else if (!src && node.children) {\n    audioSrc = parseEmbeddedSource(node);\n  } else {\n    Logger.error(\"Found an audio node but couldn't work out what its source is supposed to be.\");\n  }\n  var ret;\n  if (audioSrc) {\n    var mediaPair = getAudioElement(audioSrc, parent.audioContext);\n    ret = new _AdSourceNode[\"default\"](parent, node, undefined, mediaPair);\n  }\n  return ret;\n}\nfunction parseNode(parent, node) {\n  var ret = null;\n  if (node.fullyQualifiedName === \"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%audio\")) {\n    ret = parseAudioSourceNode(parent, node);\n  } else if (node.fullyQualifiedName === \"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%animate\")) {\n    ret = parseAnimateNode(parent, node);\n  } else if (isLeafNode(node)) {\n    ret = parseLeafNode(parent, node);\n  } else {\n    ret = parseIntermediateNode(parent, node);\n  }\n  return ret;\n}\nfunction parseLeafNode(parent, node, audioContext) {\n  var ret = new _AdLeafNode[\"default\"](parent, node, audioContext);\n  ret.children = node.children.map(parseNode.bind(null, ret));\n\n  //Remove nulls. These are nodes to nowhere. We should also remove anonymous spans if we're a leaf.\n  ret.children = ret.children.filter(function (n) {\n    return !!n && (n._xmlNode.fullyQualifiedName === \"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%audio\") || n._xmlNode.fullyQualifiedName === \"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%animate\"));\n  });\n  if (node.hasSpeech) {\n    ret.children.push(parseSpeechNode(ret, node, audioContext));\n  }\n  return ret;\n}\nfunction parseIntermediateNode(parent, node, audioContext) {\n  var ret = new _AudioNub[\"default\"](parent, node, audioContext);\n  ret.children = node.children.map(parseNode.bind(null, ret));\n  ret.children = ret.children.filter(function (n) {\n    return !!n;\n  }); //Remove nulls. These are nodes to nowhere\n\n  return ret;\n}\nfunction parseBody(parent, node, audioContext) {\n  var body = parseNode(parent, node, audioContext);\n  body.postComputeEnd();\n  return body;\n}\nfunction parseTree(audioContext, media, url, xmlTree, startRoot) {\n  var root;\n  if (startRoot) {\n    //We can't make a new AdSourceNode on the media without\n    root = startRoot;\n  } else {\n    //Make an magic source node for the media - there's no xml for this so fake it.\n    var mediaPair = {\n      media: media,\n      mediaNode: audioContext.createMediaElementSource(media)\n    };\n    root = new _AdUserControlledSourceNode[\"default\"](null, {\n      name: \"root(mediaAudio)\",\n      attributes: {\n        \"tta:gain\": defaultVideoGain,\n        \"tta:pan\": 0\n      },\n      namespaces: {\n        \"default\": _Utils[\"default\"].NS_TTML_URI,\n        xml: _Utils[\"default\"].NS_XML_URI,\n        tta: \"\".concat(_Utils[\"default\"].NS_TTML_AUDIO_URI)\n      },\n      fullyQualifiedName: \"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%tt\")\n    }, audioContext, mediaPair);\n  }\n  var defaultOutput = new _AdLeafNode[\"default\"](root, {\n    name: \"default audio out\",\n    attributes: {},\n    namespaces: {\n      xml: _Utils[\"default\"].NS_XML_URI\n    },\n    fullyQualifiedName: \"\"\n  }, audioContext);\n  defaultOutput.makeDefaultOutput();\n  root.children = [defaultOutput];\n  if (typeof url === \"string\") {\n    currentUrl = \"\".concat(url.slice(0, url.lastIndexOf(\"/\")), \"/\");\n  } else {\n    currentUrl = \"\";\n  }\n  prepareXML(xmlTree);\n  var head = getNamedChildren(\"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%head\"), xmlTree)[0];\n  if (head) {\n    grabAudioResources(head);\n  }\n  if (isName(\"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%tt\"), xmlTree)) {\n    var body = getNamedChildren(\"\".concat(_Utils[\"default\"].NS_TTML_URI, \"%%body\"), xmlTree)[0];\n    if (body) {\n      root.children.push(parseBody(root, body, null));\n    } else {\n      Logger.error(\"Couldn't find body element in the ttml document\");\n    }\n  }\n  return root;\n}\nfunction setAudioCacheStrategy(cacheStrategy) {\n  audioCacheStrategy = cacheStrategy;\n  Logger.log(\"Audio cache strategy set to \".concat(cacheStrategy === CACHE_STRATEGY_REUSE ? \"REUSE\" : \"NO CACHE\"));\n}\nfunction getAudioCacheStrategy() {\n  return audioCacheStrategy;\n}\n\n//# sourceURL=webpack://adhere-lib/./src/Parser.es6?");

/***/ }),

/***/ "./src/PlaybackProperties.es6":
/*!************************************!*\
  !*** ./src/PlaybackProperties.es6 ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar PlaybackPropertiesSingleton = /*#__PURE__*/function () {\n  function PlaybackPropertiesSingleton() {\n    var _this = this;\n    _classCallCheck(this, PlaybackPropertiesSingleton);\n    //console.log(\"Created instance\");\n\n    this.advolCallbacks = [];\n    this.advol = document.querySelector(\"#advol\");\n    this.advol.onchange = function () {\n      _this.advolCallbacks.forEach(function (callback) {\n        callback(_this.getCurrentGain());\n      });\n    };\n  }\n\n  //Fetch UI gain value\n  return _createClass(PlaybackPropertiesSingleton, [{\n    key: \"getCurrentGain\",\n    value: function getCurrentGain() {\n      //console.info(\"Call to get current gain\");\n      return parseFloat(this.advol.value);\n    }\n\n    //Register function and return its index\n  }, {\n    key: \"registerCallback\",\n    value: function registerCallback(fn) {\n      return this.advolCallbacks.push(fn) - 1;\n    }\n\n    //Deregister callback by index\n  }, {\n    key: \"deregisterCallback\",\n    value: function deregisterCallback(index) {\n      delete this.advolCallbacks[index];\n    }\n  }]);\n}();\nvar PlaybackProperties = new PlaybackPropertiesSingleton();\nvar _default = exports[\"default\"] = PlaybackProperties;\n\n//# sourceURL=webpack://adhere-lib/./src/PlaybackProperties.es6?");

/***/ }),

/***/ "./src/SpeechSourceNode.es6":
/*!**********************************!*\
  !*** ./src/SpeechSourceNode.es6 ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _AdNode2 = _interopRequireDefault(__webpack_require__(/*! ./AdNode.es6 */ \"./src/AdNode.es6\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { \"default\": e }; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); } // Copyright 2019 British Broadcasting Corporation\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// import Logger from \"./Logger.es6\";\nvar Logger = (__webpack_require__(/*! ./Logger.es6 */ \"./src/Logger.es6\").Logger);\n\n/*eslint func-style: [\"error\", \"declaration\"]*/\n\nfunction speakToRate(str) {\n  var ret;\n  switch (str) {\n    case \"fast\":\n      ret = 1.5;\n      break;\n    case \"slow\":\n      ret = 0.66;\n      break;\n    case \"normal\":\n    default:\n      ret = 1;\n      break;\n  }\n  return ret;\n}\n\n//Convert to a value between 0 and 2, 1 being a standard pitch\n//What this output number means isn't clear, and probably up to the browser\nfunction pitchToValue(str) {\n  var ret = 1;\n  if (str) {\n    var pcIdx = str.indexOf(\"%\");\n    if (pcIdx >= 0) {\n      var pcstr = str.substring(0, pcIdx);\n      ret = parseFloat(pcstr) / 100 + 1;\n    }\n  }\n  return ret;\n}\nvar SpeechSourceNode = exports[\"default\"] = /*#__PURE__*/function (_AdNode) {\n  function SpeechSourceNode(parent, xmlNode, audioContext) {\n    var _this;\n    _classCallCheck(this, SpeechSourceNode);\n    _this = _callSuper(this, SpeechSourceNode, [parent, xmlNode, audioContext]);\n    _this.utter = new SpeechSynthesisUtterance();\n    _this.utter.text = _this.value;\n    _this.utter.lang = \"en-US\";\n    _this.utter.rate = speakToRate(_this.speak);\n    _this.utter.pitch = pitchToValue(_this.pitch);\n    return _this;\n  }\n  _inherits(SpeechSourceNode, _AdNode);\n  return _createClass(SpeechSourceNode, [{\n    key: \"onActive\",\n    value: function onActive() {\n      _get(_getPrototypeOf(SpeechSourceNode.prototype), \"onActive\", this).call(this);\n      Logger.log(\"\".concat(this.name, \" active speak: \").concat(this.utter.text));\n      speechSynthesis.speak(this.utter);\n    }\n  }, {\n    key: \"onInactive\",\n    value: function onInactive() {\n      _get(_getPrototypeOf(SpeechSourceNode.prototype), \"onInactive\", this).call(this);\n      Logger.log(\"\".concat(this.name, \" inactive speak: \").concat(this.utter.text));\n      speechSynthesis.cancel(this.utter);\n    }\n  }, {\n    key: \"onPause\",\n    value: function onPause() {\n      speechSynthesis.pause();\n    }\n  }, {\n    key: \"onResume\",\n    value: function onResume() {\n      speechSynthesis.resume();\n    }\n  }]);\n}(_AdNode2[\"default\"]);\n\n//# sourceURL=webpack://adhere-lib/./src/SpeechSourceNode.es6?");

/***/ }),

/***/ "./src/TextPresenter.es6":
/*!*******************************!*\
  !*** ./src/TextPresenter.es6 ***!
  \*******************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// Copyright 2019 British Broadcasting Corporation\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// import Logger from \"./Logger.es6\";\nvar Logger = (__webpack_require__(/*! ./Logger.es6 */ \"./src/Logger.es6\").Logger);\nvar callbacks = [];\nvar presentedStrings = new Map();\nvar key = 1; // if you start with zero, the first one never leaves\n/*eslint no-console: [\"error\", { allow: [\"warn\", \"error\", \"log\", \"dir\"] }] */\nvar TextPresenter = exports[\"default\"] = /*#__PURE__*/function () {\n  function TextPresenter() {\n    _classCallCheck(this, TextPresenter);\n  }\n  return _createClass(TextPresenter, null, [{\n    key: \"present\",\n    value: function present(str, source) {\n      var thisKey = key;\n      presentedStrings.set(thisKey, str);\n      key++;\n      Logger.log(\"TP: adding key \".concat(thisKey, \" from \").concat(source, \": \").concat(str));\n      this.updatePresentedText();\n      return thisKey;\n    }\n  }, {\n    key: \"unPresent\",\n    value: function unPresent(removeKey) {\n      // remove the text with the key\n      Logger.log(\"TP: removing value for key \".concat(removeKey));\n      presentedStrings[\"delete\"](removeKey);\n      this.updatePresentedText();\n    }\n  }, {\n    key: \"updatePresentedText\",\n    value: function updatePresentedText() {\n      var generatedString = \"\";\n      presentedStrings.forEach(function (v) {\n        generatedString = v; // change = to += to concatenate, or leave as is to just show the last one\n      });\n      callbacks.forEach(function (cb) {\n        return cb(generatedString);\n      });\n    }\n  }, {\n    key: \"addCallback\",\n    value: function addCallback(cb) {\n      callbacks.push(cb);\n    }\n  }]);\n}();\nmodule.exports = exports = {\n  TextPresenter: TextPresenter\n};\n\n//# sourceURL=webpack://adhere-lib/./src/TextPresenter.es6?");

/***/ }),

/***/ "./src/TimingCalculator.es6":
/*!**********************************!*\
  !*** ./src/TimingCalculator.es6 ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// Copyright 2019 British Broadcasting Corporation\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/*eslint func-style: [\"error\", \"declaration\"]*/\n\nfunction nullOrUndefined(thing) {\n  return thing === undefined || thing === null;\n}\nfunction specified(thing) {\n  return !nullOrUndefined(thing);\n}\nvar TimingCalculator = exports[\"default\"] = /*#__PURE__*/function () {\n  function TimingCalculator() {\n    _classCallCheck(this, TimingCalculator);\n  }\n  return _createClass(TimingCalculator, null, [{\n    key: \"parseTimeString\",\n    value: function parseTimeString(timeStr) {\n      var rgx = /(\\d{2,}):(\\d{2,}):(\\d{2}(?:\\.\\d*)?)/;\n      var groups = timeStr.match(rgx);\n      var hours = parseInt(groups[1]);\n      var mins = parseInt(groups[2]);\n      var secs = parseFloat(groups[3]);\n      var total = hours * 3600 + mins * 60 + secs;\n      return total;\n    }\n  }, {\n    key: \"parseSeconds\",\n    value: function parseSeconds(timeText) {\n      var lowerTimeText = timeText.toLowerCase();\n      var isSecondsString = lowerTimeText.charAt(timeText.length - 1) === \"s\";\n      return isSecondsString ? this.parseSecondText(timeText) : this.parseTimeString(timeText);\n    }\n  }, {\n    key: \"parseSecondText\",\n    value: function parseSecondText(timingText) {\n      var timing = String(timingText);\n      timing = timing.substring(0, timing.length - 1);\n      return parseFloat(timing);\n    }\n  }, {\n    key: \"computeBegin\",\n    value: function computeBegin(element) {\n      var parent = element.parent;\n      var syncbase = parent ? this.computeBegin(parent) : 0;\n      var beginAttr = element.attributes.begin;\n      var begin = beginAttr ? this.parseSeconds(beginAttr) : 0;\n      return syncbase + begin;\n    }\n  }, {\n    key: \"computeEnd\",\n    value: function computeEnd(element) {\n      var _this = this;\n      var seekUp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var end = this.getSpecifiedEnd(element, seekUp);\n      if (nullOrUndefined(end)) {\n        // now we have to get the biggest defined end from each child\n        var ends = [];\n        element.children.forEach(function (c) {\n          ends.push(_this.computeEnd(c, false));\n        });\n        if (!ends.includes(undefined) && ends.length > 0) {\n          end = Math.max.apply(Math, ends);\n        }\n      }\n      return end;\n    }\n  }, {\n    key: \"getSpecifiedEnd\",\n    value: function getSpecifiedEnd(element) {\n      var seekUp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var parentEnd;\n      var resultingSpecifiedEnd;\n      var parent = element.parent;\n      if (seekUp && parent) {\n        parentEnd = this.getSpecifiedEnd(parent);\n      }\n      var syncbase = parent ? this.computeBegin(parent) : 0;\n      var thisEnd = element.attributes.end ? this.parseSeconds(element.attributes.end) + syncbase : undefined;\n      if (specified(thisEnd)) {\n        if (specified(parentEnd)) {\n          resultingSpecifiedEnd = Math.min(thisEnd, parentEnd);\n        } else {\n          resultingSpecifiedEnd = thisEnd;\n        }\n      } else {\n        // we don't specify an end\n        resultingSpecifiedEnd = parentEnd;\n      }\n      return resultingSpecifiedEnd;\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://adhere-lib/./src/TimingCalculator.es6?");

/***/ }),

/***/ "./src/TrackAPIHelper.es6":
/*!********************************!*\
  !*** ./src/TrackAPIHelper.es6 ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// Copyright 2019 British Broadcasting Corporation\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar TrackAPIHelper = exports[\"default\"] = /*#__PURE__*/function () {\n  function TrackAPIHelper(videoPlayer) {\n    _classCallCheck(this, TrackAPIHelper);\n    this.video = videoPlayer;\n    this.track = videoPlayer.addTextTrack(\"metadata\");\n  }\n  return _createClass(TrackAPIHelper, [{\n    key: \"addCue\",\n    value: function addCue(newCue) {\n      this.track.addCue(newCue);\n    }\n  }, {\n    key: \"removeCues\",\n    value: function removeCues() {\n      while (this.track.cues.length > 0) {\n        this.track.removeCue(this.track.cues[0]);\n      }\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://adhere-lib/./src/TrackAPIHelper.es6?");

/***/ }),

/***/ "./src/Utils.es6":
/*!***********************!*\
  !*** ./src/Utils.es6 ***!
  \***********************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// Copyright 2019 British Broadcasting Corporation\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar Utils = exports[\"default\"] = /*#__PURE__*/function () {\n  function Utils() {\n    _classCallCheck(this, Utils);\n  }\n  return _createClass(Utils, null, [{\n    key: \"NS_XML_URI\",\n    get: function get() {\n      return \"http://www.w3.org/XML/1998/namespace\";\n    }\n  }, {\n    key: \"NS_TTML_URI\",\n    get: function get() {\n      return \"http://www.w3.org/ns/ttml\";\n    }\n  }, {\n    key: \"NS_TTML_PARAMETER_URI\",\n    get: function get() {\n      return \"http://www.w3.org/ns/ttml#parameter\";\n    }\n  }, {\n    key: \"NS_TTML_STYLING_URI\",\n    get: function get() {\n      return \"http://www.w3.org/ns/ttml#styling\";\n    }\n  }, {\n    key: \"NS_TTML_AUDIO_URI\",\n    get: function get() {\n      return \"http://www.w3.org/ns/ttml#audio\";\n    }\n  }, {\n    key: \"NS_TTML_METADATA_URI\",\n    get: function get() {\n      return \"http://www.w3.org/ns/ttml#metadata\";\n    }\n  }, {\n    key: \"NS_TTML_ISD_URI\",\n    get: function get() {\n      return \"http://www.w3.org/ns/ttml#isd\";\n    }\n  }, {\n    key: \"isUndefined\",\n    value: function isUndefined(element) {\n      return element === null || element === undefined || element.attributes === undefined || element.name === undefined;\n    }\n  }, {\n    key: \"isAudioType\",\n    value: function isAudioType(fullyQualifiedName) {\n      return fullyQualifiedName === \"\".concat(Utils.NS_TTML_URI, \"%%body\") || fullyQualifiedName === \"\".concat(Utils.NS_TTML_URI, \"%%div\") || fullyQualifiedName === \"\".concat(Utils.NS_TTML_URI, \"%%p\") || fullyQualifiedName === \"\".concat(Utils.NS_TTML_URI, \"%%span\") || fullyQualifiedName === \"\".concat(Utils.NS_TTML_URI, \"%%animate\") || fullyQualifiedName === \"\".concat(Utils.NS_TTML_URI, \"%%audio\") || fullyQualifiedName === \"\".concat(Utils.NS_TTML_URI, \"%%source\") || fullyQualifiedName === \"\".concat(Utils.NS_TTML_URI, \"%%data\") || fullyQualifiedName === \"\".concat(Utils.NS_TTML_URI, \"%%chunk\") || fullyQualifiedName === \"\";\n    }\n  }, {\n    key: \"hasAudioAttribute\",\n    value: function hasAudioAttribute(element) {\n      return this.getAttributeByFullyQualifiedName(element, \"\".concat(Utils.NS_TTML_URI, \"#audio%%gain\")) !== undefined || this.getAttributeByFullyQualifiedName(element, \"\".concat(Utils.NS_TTML_URI, \"#audio%%pan\")) !== undefined || this.getAttributeByFullyQualifiedName(element, \"\".concat(Utils.NS_TTML_URI, \"#audio%%pitch\")) !== undefined || this.getAttributeByFullyQualifiedName(element, \"\".concat(Utils.NS_TTML_URI, \"#audio%%speak\")) !== undefined;\n    }\n  }, {\n    key: \"isAudioElement\",\n    value: function isAudioElement(element) {\n      if (Utils.isUndefined(element)) {\n        return false;\n      }\n      var fullyQualifiedName = element.fullyQualifiedName;\n      if (fullyQualifiedName === \"\".concat(Utils.NS_TTML_URI, \"%%audio\") || fullyQualifiedName === \"\".concat(Utils.NS_TTML_URI, \"%%source\") || fullyQualifiedName === \"\".concat(Utils.NS_TTML_URI, \"%%data\") || fullyQualifiedName === \"\".concat(Utils.NS_TTML_URI, \"%%chunk\")) {\n        return true;\n      }\n      return Utils.isAudioType(fullyQualifiedName) && Utils.hasAudioAttribute(element);\n    }\n  }, {\n    key: \"gleanNamespaces\",\n    value: function gleanNamespaces(element) {\n      var namespaces = {\n        xml: Utils.NS_XML_URI\n      };\n      for (var key in element.attributes) {\n        if (element.attributes.hasOwnProperty(key)) {\n          if (key === \"xmlns\") {\n            namespaces[\"default\"] = element.attributes[key];\n          } else if (key === \"xmlns:xml\" && element.attributes[key] !== Utils.NS_XML_URI) {\n            console.warn(\"Namespace xmlns:xml is reserved in XML and must not be bound to another namespace!\");\n            console.warn(\"\".concat(key, \"=\").concat(element.attributes[key], \" is ignored.\"));\n          } else if (key.startsWith(\"xmlns:\")) {\n            namespaces[key.split(\":\")[1]] = element.attributes[key];\n          } else continue;\n        }\n      }\n      return namespaces;\n    }\n  }, {\n    key: \"getFullyQualifiedName\",\n    value: function getFullyQualifiedName(element) {\n      if (element.name.includes(\":\")) {\n        var prefix = element.name.split(\":\")[0];\n        var suffix = element.name.split(\":\")[1];\n        if (element.namespaces.hasOwnProperty(prefix)) {\n          return \"\".concat(element.namespaces[prefix], \"%%\").concat(suffix);\n        } else {\n          console.warn(\"Cannot find the namespace for element \".concat(element.name, \". Make sure your TTML2 file is valid XML.\"));\n          return undefined;\n        }\n      }\n      return element.name === \"\" ? \"\" : \"\".concat(element.namespaces[\"default\"], \"%%\").concat(element.name);\n    }\n  }, {\n    key: \"getAttributeByFullyQualifiedName\",\n    value: function getAttributeByFullyQualifiedName(element, fullyQualifiedAttributeName) {\n      if (fullyQualifiedAttributeName.includes(\"%%\")) {\n        var namespaceURI = fullyQualifiedAttributeName.split(\"%%\")[0];\n        var name = fullyQualifiedAttributeName.split(\"%%\")[1];\n        if (namespaceURI === \"\" && element.attributes.hasOwnProperty(name)) {\n          return element.attributes[name];\n        }\n        for (var prefix in element.namespaces) {\n          if (namespaceURI === element.namespaces[prefix] && element.attributes.hasOwnProperty(\"\".concat(prefix, \":\").concat(name))) {\n            return element.attributes[\"\".concat(prefix, \":\").concat(name)];\n          }\n        }\n      }\n      return undefined;\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://adhere-lib/./src/Utils.es6?");

/***/ }),

/***/ "./src/VideoAudioHook.es6":
/*!********************************!*\
  !*** ./src/VideoAudioHook.es6 ***!
  \********************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _Utils = _interopRequireDefault(__webpack_require__(/*! ./Utils.es6 */ \"./src/Utils.es6\"));\nvar _TrackAPIHelper = _interopRequireDefault(__webpack_require__(/*! ./TrackAPIHelper.es6 */ \"./src/TrackAPIHelper.es6\"));\nvar _XMLReader = _interopRequireDefault(__webpack_require__(/*! ./XMLReader.es6 */ \"./src/XMLReader.es6\"));\nvar _Parser = _interopRequireWildcard(__webpack_require__(/*! ./Parser.es6 */ \"./src/Parser.es6\"));\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return { \"default\": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n[\"default\"] = e, t && t.set(e, n), n; }\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { \"default\": e }; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); } // Copyright 2019 British Broadcasting Corporation\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// import Logger from \"./Logger.es6\";\nvar Logger = (__webpack_require__(/*! ./Logger.es6 */ \"./src/Logger.es6\").Logger);\nvar VideoAudioHook = exports[\"default\"] = /*#__PURE__*/function () {\n  function VideoAudioHook(videoplayer) {\n    _classCallCheck(this, VideoAudioHook);\n    this.videoplayer = videoplayer;\n    this.Utils = _Utils[\"default\"];\n    this.TrackApi = _TrackAPIHelper[\"default\"];\n    this.XMLReader = _XMLReader[\"default\"];\n    this.FileReader = FileReader;\n    this.firstTime = true;\n    this.videoplayer.addEventListener(\"play\", this.onVideoPlay.bind(this));\n    this.videoplayer.addEventListener(\"pause\", this.onVideoPause.bind(this));\n  }\n  return _createClass(VideoAudioHook, [{\n    key: \"setup\",\n    value: function setup() {\n      this.xmlReader = new this.XMLReader();\n      this.track = new this.TrackApi(this.videoplayer);\n    }\n  }, {\n    key: \"attachTTMLfromFile\",\n    value: function attachTTMLfromFile(ttmlFile) {\n      var _this = this;\n      var reader = new this.FileReader();\n      reader.onload = function () {\n        _this.parseTTML(ttmlFile, reader.result);\n      };\n      Logger.log(\"Reading TTML file at: \".concat(ttmlFile));\n      reader.readAsText(ttmlFile);\n    }\n  }, {\n    key: \"attachTTMLfromURL\",\n    value: function attachTTMLfromURL(ttmlURL) {\n      var _this2 = this;\n      Logger.log(\"Fetching TTML from URL at: \".concat(ttmlURL));\n      fetch(ttmlURL).then(function (response) {\n        if (!response.ok) throw Error(response.statusText);\n        return response.text().then(function (text) {\n          _this2.parseTTML(ttmlURL, text);\n        });\n      });\n    }\n  }, {\n    key: \"getHttpTTML\",\n    value: function getHttpTTML(ttmlUrl) {\n      var xhr = new XMLHttpRequest();\n      xhr.open(\"GET\", ttmlUrl);\n      xhr.addEventListener(\"load\", this.onTTMLLoad.bind(this));\n      Logger.log(\"GET ttml at: \".concat(ttmlUrl));\n      xhr.send();\n    }\n  }, {\n    key: \"onTTMLLoad\",\n    value: function onTTMLLoad(e) {\n      this.parseTTML(e.target.responseURL, e.target.responseText);\n    }\n  }, {\n    key: \"parseTTML\",\n    value: function parseTTML(url, result) {\n      var media = this.videoplayer;\n      this.xmlReader.parseXML(result, function () {\n        return null;\n      }, this.setupTree.bind(this, media, url));\n    }\n  }, {\n    key: \"audioCacheStrategy\",\n    get: function get() {\n      return (0, _Parser.getAudioCacheStrategy)();\n    },\n    set: function set(cacheStrategy) {\n      (0, _Parser.setAudioCacheStrategy)(cacheStrategy);\n    }\n  }, {\n    key: \"setupTree\",\n    value: function setupTree(media, documentPath, xmlTree) {\n      var _this3 = this;\n      if (this.tree) {\n        this.resetTree();\n      }\n\n      // Work around Webkit, which currently offers the prefixed version only\n      var AudioContext = window.AudioContext || window.webkitAudioContext;\n      var audioContext = this.tree ? this.tree.audioContext : new AudioContext();\n      this.tree = (0, _Parser[\"default\"])(audioContext, media, documentPath, xmlTree, this.tree);\n      var cues = [];\n      Logger.log(\"VideoAudioHook.setupTree media.duration = \".concat(media.duration));\n      this.tree.makeCueObjects(cues, media);\n      cues.forEach(function (c) {\n        _this3.track.addCue(c);\n      });\n      if (this.videoplayer.currentTime > 0) {\n        this.activateTree();\n        this.videoplayer.currentTime = 0;\n      }\n    }\n\n    //For all nodes in the tree with a NaN beginning, activate them.\n    //We can't do this until play() - Else audio sources without bbegin will start on load\n  }, {\n    key: \"activateTree\",\n    value: function activateTree() {\n      this.tree.traverse(function (c) {\n        if (isNaN(c.begin)) {\n          c.onActive();\n        }\n      });\n    }\n\n    //onFinalise() goes a little further than onInactive\n    //onInactive should be sufficient for audionode garbage collection, but it's not clear if it's the case\n    //Firefox webaudio tab shows audionodes persisting(actually though?) long after use and disconnection\n    //At the very least, we need to revokeObjectURL.\n  }, {\n    key: \"resetTree\",\n    value: function resetTree() {\n      this.track.removeCues();\n      this.tree.traverse(function (c) {\n        if (typeof c.onFinalise === \"function\") {\n          c.onFinalise();\n        }\n      });\n      this.tree.children = [];\n    }\n  }, {\n    key: \"onVideoPlay\",\n    value: function onVideoPlay() {\n      var _this4 = this;\n      var audioContext = this.tree.audioContext;\n      if (audioContext) {\n        Logger.log(\"resuming audio context\");\n        audioContext.resume().then(function () {\n          if (_this4.firstTime) {\n            _this4.activateTree();\n            _this4.firstTime = false;\n          } else {\n            _this4.tree.traverse(function (c) {\n              if (typeof c.onRestart === \"function\") {\n                c.onRestart();\n              }\n            });\n          }\n        });\n      }\n    }\n  }, {\n    key: \"onVideoPause\",\n    value: function onVideoPause() {\n      var _this5 = this;\n      var audioContext = this.tree.audioContext;\n      if (audioContext && audioContext.state === \"running\") {\n        Logger.log(\"suspending audio context\");\n        audioContext.suspend().then(function () {\n          _this5.tree.traverse(function (c) {\n            if (typeof c.onPause === \"function\") {\n              c.onPause();\n            }\n          });\n        });\n      }\n    }\n  }]);\n}();\nmodule.exports = exports = {\n  VideoAudioHook: VideoAudioHook\n};\n\n//# sourceURL=webpack://adhere-lib/./src/VideoAudioHook.es6?");

/***/ }),

/***/ "./src/XMLReader.es6":
/*!***************************!*\
  !*** ./src/XMLReader.es6 ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _xmlReader = _interopRequireDefault(__webpack_require__(/*! xml-reader */ \"./node_modules/xml-reader/dist/reader.js\"));\nvar _xmlQuery = _interopRequireDefault(__webpack_require__(/*! xml-query */ \"./node_modules/xml-query/dist/index.js\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { \"default\": e }; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); } // Copyright 2019 British Broadcasting Corporation\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar XMLReader = exports[\"default\"] = /*#__PURE__*/function () {\n  function XMLReader() {\n    _classCallCheck(this, XMLReader);\n    this.xmlReader = _xmlReader[\"default\"].create();\n    this.xmlQuery = _xmlQuery[\"default\"];\n  }\n  return _createClass(XMLReader, [{\n    key: \"parseXML\",\n    value: function parseXML(ttmlFile, processDiv, doneCB) {\n      this.xmlReader.reset();\n      this.xmlReader.once(\"done\", doneCB);\n      this.xmlReader.parse(ttmlFile);\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://adhere-lib/./src/XMLReader.es6?");

/***/ }),

/***/ "./src/index.es6":
/*!***********************!*\
  !*** ./src/index.es6 ***!
  \***********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nObject.defineProperty(exports, \"Logger\", ({\n  enumerable: true,\n  get: function get() {\n    return _Logger.Logger;\n  }\n}));\nObject.defineProperty(exports, \"TextPresenter\", ({\n  enumerable: true,\n  get: function get() {\n    return _TextPresenter.TextPresenter;\n  }\n}));\nObject.defineProperty(exports, \"VideoAudioHook\", ({\n  enumerable: true,\n  get: function get() {\n    return _VideoAudioHook.VideoAudioHook;\n  }\n}));\n__webpack_require__(/*! regenerator-runtime/runtime */ \"./node_modules/regenerator-runtime/runtime.js\");\nvar _VideoAudioHook = __webpack_require__(/*! ./VideoAudioHook.es6 */ \"./src/VideoAudioHook.es6\");\nvar _TextPresenter = __webpack_require__(/*! ./TextPresenter.es6 */ \"./src/TextPresenter.es6\");\nvar _Logger = __webpack_require__(/*! ./Logger.es6 */ \"./src/Logger.es6\");\n\n//# sourceURL=webpack://adhere-lib/./src/index.es6?");

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack://adhere-lib/./node_modules/base64-js/index.js?");

/***/ }),

/***/ "./node_modules/eventemitter3/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eventemitter3/index.js ***!
  \*********************************************/
/***/ ((module) => {

eval("\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @api private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {Mixed} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @api private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @api public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @api public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {String|Symbol} event The event name.\n * @param {Boolean} exists Only check if there are listeners.\n * @returns {Array|Boolean}\n * @api public\n */\nEventEmitter.prototype.listeners = function listeners(event, exists) {\n  var evt = prefix ? prefix + event : event\n    , available = this._events[evt];\n\n  if (exists) return !!available;\n  if (!available) return [];\n  if (available.fn) return [available.fn];\n\n  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {\n    ee[i] = available[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {String|Symbol} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @api public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {String|Symbol} event The event name.\n * @param {Function} fn The listener function.\n * @param {Mixed} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @api public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  var listener = new EE(fn, context || this)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;\n  else if (!this._events[evt].fn) this._events[evt].push(listener);\n  else this._events[evt] = [this._events[evt], listener];\n\n  return this;\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {String|Symbol} event The event name.\n * @param {Function} fn The listener function.\n * @param {Mixed} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @api public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  var listener = new EE(fn, context || this, true)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;\n  else if (!this._events[evt].fn) this._events[evt].push(listener);\n  else this._events[evt] = [this._events[evt], listener];\n\n  return this;\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {String|Symbol} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {Mixed} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @api public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    if (--this._eventsCount === 0) this._events = new Events();\n    else delete this._events[evt];\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n         listeners.fn === fn\n      && (!once || listeners.once)\n      && (!context || listeners.context === context)\n    ) {\n      if (--this._eventsCount === 0) this._events = new Events();\n      else delete this._events[evt];\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n           listeners[i].fn !== fn\n        || (once && !listeners[i].once)\n        || (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else if (--this._eventsCount === 0) this._events = new Events();\n    else delete this._events[evt];\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {String|Symbol} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @api public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) {\n      if (--this._eventsCount === 0) this._events = new Events();\n      else delete this._events[evt];\n    }\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// This function doesn't apply anymore.\n//\nEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n  return this;\n};\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n\n\n//# sourceURL=webpack://adhere-lib/./node_modules/eventemitter3/index.js?");

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; };\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) });\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: true });\n  defineProperty(\n    GeneratorFunctionPrototype,\n    \"constructor\",\n    { value: GeneratorFunction, configurable: true }\n  );\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    defineProperty(this, \"_invoke\", { value: enqueue });\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per GeneratorResume behavior specified since ES2015:\n        // ES2015 spec, step 3: https://262.ecma-international.org/6.0/#sec-generatorresume\n        // Latest spec, step 2: https://tc39.es/ecma262/#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var methodName = context.method;\n    var method = delegate.iterator[methodName];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method, or a missing .next method, always terminate the\n      // yield* loop.\n      context.delegate = null;\n\n      // Note: [\"return\"] must be used for ES3 parsing compatibility.\n      if (methodName === \"throw\" && delegate.iterator[\"return\"]) {\n        // If the delegate iterator has a return method, give it a\n        // chance to clean up.\n        context.method = \"return\";\n        context.arg = undefined;\n        maybeInvokeDelegate(delegate, context);\n\n        if (context.method === \"throw\") {\n          // If maybeInvokeDelegate(context) changed context.method from\n          // \"return\" to \"throw\", let that override the TypeError below.\n          return ContinueSentinel;\n        }\n      }\n      if (methodName !== \"return\") {\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a '\" + methodName + \"' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(val) {\n    var object = Object(val);\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable != null) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    throw new TypeError(typeof iterable + \" is not iterable\");\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n   true ? module.exports : 0\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n\n\n//# sourceURL=webpack://adhere-lib/./node_modules/regenerator-runtime/runtime.js?");

/***/ }),

/***/ "./node_modules/xml-lexer/dist/lexer.js":
/*!**********************************************!*\
  !*** ./node_modules/xml-lexer/dist/lexer.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar EventEmitter = __webpack_require__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\");\nvar noop = function noop() {};\n\nvar State = {\n    data: 'state-data',\n    cdata: 'state-cdata',\n    tagBegin: 'state-tag-begin',\n    tagName: 'state-tag-name',\n    tagEnd: 'state-tag-end',\n    attributeNameStart: 'state-attribute-name-start',\n    attributeName: 'state-attribute-name',\n    attributeNameEnd: 'state-attribute-name-end',\n    attributeValueBegin: 'state-attribute-value-begin',\n    attributeValue: 'state-attribute-value'\n};\n\nvar Action = {\n    lt: 'action-lt',\n    gt: 'action-gt',\n    space: 'action-space',\n    equal: 'action-equal',\n    quote: 'action-quote',\n    slash: 'action-slash',\n    char: 'action-char',\n    error: 'action-error'\n};\n\nvar Type = {\n    text: 'text',\n    openTag: 'open-tag',\n    closeTag: 'close-tag',\n    attributeName: 'attribute-name',\n    attributeValue: 'attribute-value'\n};\n\nvar charToAction = {\n    ' ': Action.space,\n    '\\t': Action.space,\n    '\\n': Action.space,\n    '\\r': Action.space,\n    '<': Action.lt,\n    '>': Action.gt,\n    '\"': Action.quote,\n    \"'\": Action.quote,\n    '=': Action.equal,\n    '/': Action.slash\n};\n\nvar getAction = function getAction(char) {\n    return charToAction[char] || Action.char;\n};\n\n/**\n * @param  {Object} options\n * @param  {Boolean} options.debug\n * @return {Object}\n */\nvar create = function create(options) {\n    var _State$data, _State$tagBegin, _State$tagName, _State$tagEnd, _State$attributeNameS, _State$attributeName, _State$attributeNameE, _State$attributeValue, _State$attributeValue2, _lexer$stateMachine;\n\n    options = Object.assign({ debug: false }, options);\n    var lexer = new EventEmitter();\n    var state = State.data;\n    var data = '';\n    var tagName = '';\n    var attrName = '';\n    var attrValue = '';\n    var isClosing = '';\n    var openingQuote = '';\n\n    var emit = function emit(type, value) {\n        // for now, ignore tags like: '?xml', '!DOCTYPE' or comments\n        if (tagName[0] === '?' || tagName[0] === '!') {\n            return;\n        }\n        var event = { type: type, value: value };\n        if (options.debug) {\n            console.log('emit:', event);\n        }\n        lexer.emit('data', event);\n    };\n\n    lexer.stateMachine = (_lexer$stateMachine = {}, _defineProperty(_lexer$stateMachine, State.data, (_State$data = {}, _defineProperty(_State$data, Action.lt, function () {\n        if (data.trim()) {\n            emit(Type.text, data);\n        }\n        tagName = '';\n        isClosing = false;\n        state = State.tagBegin;\n    }), _defineProperty(_State$data, Action.char, function (char) {\n        data += char;\n    }), _State$data)), _defineProperty(_lexer$stateMachine, State.cdata, _defineProperty({}, Action.char, function (char) {\n        data += char;\n        if (data.substr(-3) === ']]>') {\n            emit(Type.text, data.slice(0, -3));\n            data = '';\n            state = State.data;\n        }\n    })), _defineProperty(_lexer$stateMachine, State.tagBegin, (_State$tagBegin = {}, _defineProperty(_State$tagBegin, Action.space, noop), _defineProperty(_State$tagBegin, Action.char, function (char) {\n        tagName = char;\n        state = State.tagName;\n    }), _defineProperty(_State$tagBegin, Action.slash, function () {\n        tagName = '';\n        isClosing = true;\n    }), _State$tagBegin)), _defineProperty(_lexer$stateMachine, State.tagName, (_State$tagName = {}, _defineProperty(_State$tagName, Action.space, function () {\n        if (isClosing) {\n            state = State.tagEnd;\n        } else {\n            state = State.attributeNameStart;\n            emit(Type.openTag, tagName);\n        }\n    }), _defineProperty(_State$tagName, Action.gt, function () {\n        if (isClosing) {\n            emit(Type.closeTag, tagName);\n        } else {\n            emit(Type.openTag, tagName);\n        }\n        data = '';\n        state = State.data;\n    }), _defineProperty(_State$tagName, Action.slash, function () {\n        state = State.tagEnd;\n        emit(Type.openTag, tagName);\n    }), _defineProperty(_State$tagName, Action.char, function (char) {\n        tagName += char;\n        if (tagName === '![CDATA[') {\n            state = State.cdata;\n            data = '';\n            tagName = '';\n        }\n    }), _State$tagName)), _defineProperty(_lexer$stateMachine, State.tagEnd, (_State$tagEnd = {}, _defineProperty(_State$tagEnd, Action.gt, function () {\n        emit(Type.closeTag, tagName);\n        data = '';\n        state = State.data;\n    }), _defineProperty(_State$tagEnd, Action.char, noop), _State$tagEnd)), _defineProperty(_lexer$stateMachine, State.attributeNameStart, (_State$attributeNameS = {}, _defineProperty(_State$attributeNameS, Action.char, function (char) {\n        attrName = char;\n        state = State.attributeName;\n    }), _defineProperty(_State$attributeNameS, Action.gt, function () {\n        data = '';\n        state = State.data;\n    }), _defineProperty(_State$attributeNameS, Action.space, noop), _defineProperty(_State$attributeNameS, Action.slash, function () {\n        isClosing = true;\n        state = State.tagEnd;\n    }), _State$attributeNameS)), _defineProperty(_lexer$stateMachine, State.attributeName, (_State$attributeName = {}, _defineProperty(_State$attributeName, Action.space, function () {\n        state = State.attributeNameEnd;\n    }), _defineProperty(_State$attributeName, Action.equal, function () {\n        emit(Type.attributeName, attrName);\n        state = State.attributeValueBegin;\n    }), _defineProperty(_State$attributeName, Action.gt, function () {\n        attrValue = '';\n        emit(Type.attributeName, attrName);\n        emit(Type.attributeValue, attrValue);\n        data = '';\n        state = State.data;\n    }), _defineProperty(_State$attributeName, Action.slash, function () {\n        isClosing = true;\n        attrValue = '';\n        emit(Type.attributeName, attrName);\n        emit(Type.attributeValue, attrValue);\n        state = State.tagEnd;\n    }), _defineProperty(_State$attributeName, Action.char, function (char) {\n        attrName += char;\n    }), _State$attributeName)), _defineProperty(_lexer$stateMachine, State.attributeNameEnd, (_State$attributeNameE = {}, _defineProperty(_State$attributeNameE, Action.space, noop), _defineProperty(_State$attributeNameE, Action.equal, function () {\n        emit(Type.attributeName, attrName);\n        state = State.attributeValueBegin;\n    }), _defineProperty(_State$attributeNameE, Action.gt, function () {\n        attrValue = '';\n        emit(Type.attributeName, attrName);\n        emit(Type.attributeValue, attrValue);\n        data = '';\n        state = State.data;\n    }), _defineProperty(_State$attributeNameE, Action.char, function (char) {\n        attrValue = '';\n        emit(Type.attributeName, attrName);\n        emit(Type.attributeValue, attrValue);\n        attrName = char;\n        state = State.attributeName;\n    }), _State$attributeNameE)), _defineProperty(_lexer$stateMachine, State.attributeValueBegin, (_State$attributeValue = {}, _defineProperty(_State$attributeValue, Action.space, noop), _defineProperty(_State$attributeValue, Action.quote, function (char) {\n        openingQuote = char;\n        attrValue = '';\n        state = State.attributeValue;\n    }), _defineProperty(_State$attributeValue, Action.gt, function () {\n        attrValue = '';\n        emit(Type.attributeValue, attrValue);\n        data = '';\n        state = State.data;\n    }), _defineProperty(_State$attributeValue, Action.char, function (char) {\n        openingQuote = '';\n        attrValue = char;\n        state = State.attributeValue;\n    }), _State$attributeValue)), _defineProperty(_lexer$stateMachine, State.attributeValue, (_State$attributeValue2 = {}, _defineProperty(_State$attributeValue2, Action.space, function (char) {\n        if (openingQuote) {\n            attrValue += char;\n        } else {\n            emit(Type.attributeValue, attrValue);\n            state = State.attributeNameStart;\n        }\n    }), _defineProperty(_State$attributeValue2, Action.quote, function (char) {\n        if (openingQuote === char) {\n            emit(Type.attributeValue, attrValue);\n            state = State.attributeNameStart;\n        } else {\n            attrValue += char;\n        }\n    }), _defineProperty(_State$attributeValue2, Action.gt, function (char) {\n        if (openingQuote) {\n            attrValue += char;\n        } else {\n            emit(Type.attributeValue, attrValue);\n            data = '';\n            state = State.data;\n        }\n    }), _defineProperty(_State$attributeValue2, Action.slash, function (char) {\n        if (openingQuote) {\n            attrValue += char;\n        } else {\n            emit(Type.attributeValue, attrValue);\n            isClosing = true;\n            state = State.tagEnd;\n        }\n    }), _defineProperty(_State$attributeValue2, Action.char, function (char) {\n        attrValue += char;\n    }), _State$attributeValue2)), _lexer$stateMachine);\n\n    var step = function step(char) {\n        if (options.debug) {\n            console.log(state, char);\n        }\n        var actions = lexer.stateMachine[state];\n        var action = actions[getAction(char)] || actions[Action.error] || actions[Action.char];\n        action(char);\n    };\n\n    lexer.write = function (str) {\n        var len = str.length;\n        for (var i = 0; i < len; i++) {\n            step(str[i]);\n        }\n    };\n\n    return lexer;\n};\n\nmodule.exports = {\n    State: State,\n    Action: Action,\n    Type: Type,\n    create: create\n};\n\n//# sourceURL=webpack://adhere-lib/./node_modules/xml-lexer/dist/lexer.js?");

/***/ }),

/***/ "./node_modules/xml-query/dist/index.js":
/*!**********************************************!*\
  !*** ./node_modules/xml-query/dist/index.js ***!
  \**********************************************/
/***/ ((module) => {

eval("\nvar flatMap = function (arr, fn) {\n    return Array.prototype.concat.apply([], arr.map(fn));\n};\nvar xmlQuery = function (ast) {\n    var nodes = Array.isArray(ast) ? ast : (ast ? [ast] : []);\n    var length = nodes.length;\n    var get = function (index) { return nodes[index]; };\n    var children = function () {\n        return xmlQuery(flatMap(nodes, function (node) { return node.children; }));\n    };\n    var findInNode = function (node, sel) {\n        var res = (node.name === sel) ? [node] : [];\n        return res.concat(flatMap(node.children, function (node) { return findInNode(node, sel); }));\n    };\n    var find = function (sel) {\n        return xmlQuery(flatMap(nodes, function (node) { return findInNode(node, sel); }));\n    };\n    var has = function (sel) {\n        if (nodes.length === 0) {\n            return false;\n        }\n        if (nodes.some(function (node) { return node.name === sel; })) {\n            return true;\n        }\n        return children().has(sel);\n    };\n    var attr = function (name) {\n        if (length) {\n            var attrs = nodes[0].attributes;\n            return name ? attrs[name] : attrs;\n        }\n    };\n    var eq = function (index) { return xmlQuery(nodes[index]); };\n    var first = function () { return eq(0); };\n    var last = function () { return eq(length - 1); };\n    var map = function (fn) { return nodes.map(fn); };\n    var each = function (fn) { return nodes.forEach(fn); };\n    var size = function () { return length; };\n    var prop = function (name) {\n        var node = get(0);\n        if (node) {\n            return node[name];\n        }\n    };\n    var text = function () {\n        var res = '';\n        each(function (node) {\n            if (node.type === 'text') {\n                res += node.value;\n            }\n            else {\n                res += xmlQuery(node).children().text();\n            }\n        });\n        return res;\n    };\n    return {\n        attr: attr,\n        children: children,\n        each: each,\n        eq: eq,\n        find: find,\n        has: has,\n        first: first,\n        get: get,\n        last: last,\n        length: length,\n        map: map,\n        prop: prop,\n        size: size,\n        text: text,\n        ast: ast,\n    };\n};\nmodule.exports = xmlQuery;\n\n\n//# sourceURL=webpack://adhere-lib/./node_modules/xml-query/dist/index.js?");

/***/ }),

/***/ "./node_modules/xml-reader/dist/reader.js":
/*!************************************************!*\
  !*** ./node_modules/xml-reader/dist/reader.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar EventEmitter = __webpack_require__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\");\nvar Lexer = __webpack_require__(/*! xml-lexer */ \"./node_modules/xml-lexer/dist/lexer.js\");\nvar Type = Lexer.Type;\n\nvar NodeType = {\n    element: 'element',\n    text: 'text'\n};\n\nvar createNode = function createNode(params) {\n    return Object.assign({\n        name: '',\n        type: NodeType.element,\n        value: '',\n        parent: null,\n        attributes: {},\n        children: []\n    }, params);\n};\n\nvar create = function create(options) {\n    options = Object.assign({\n        stream: false,\n        parentNodes: true,\n        doneEvent: 'done',\n        tagPrefix: 'tag:',\n        emitTopLevelOnly: false,\n        debug: false\n    }, options);\n\n    var lexer = void 0,\n        rootNode = void 0,\n        current = void 0,\n        attrName = void 0;\n\n    var reader = new EventEmitter();\n\n    var handleLexerData = function handleLexerData(data) {\n        switch (data.type) {\n\n            case Type.openTag:\n                if (current === null) {\n                    current = rootNode;\n                    current.name = data.value;\n                } else {\n                    var node = createNode({\n                        name: data.value,\n                        parent: current\n                    });\n                    current.children.push(node);\n                    current = node;\n                }\n                break;\n\n            case Type.closeTag:\n                var parent = current.parent;\n                if (!options.parentNodes) {\n                    current.parent = null;\n                }\n                if (current.name !== data.value) {\n                    // ignore unexpected closing tag\n                    break;\n                }\n                if (options.stream && parent === rootNode) {\n                    rootNode.children = [];\n                    // do not expose parent node in top level nodes\n                    current.parent = null;\n                }\n                if (!options.emitTopLevelOnly || parent === rootNode) {\n                    reader.emit(options.tagPrefix + current.name, current);\n                    reader.emit('tag', current.name, current);\n                }\n                if (current === rootNode) {\n                    // end of document, stop listening\n                    lexer.removeAllListeners('data');\n                    reader.emit(options.doneEvent, current);\n                    rootNode = null;\n                }\n                current = parent;\n                break;\n\n            case Type.text:\n                if (current) {\n                    current.children.push(createNode({\n                        type: NodeType.text,\n                        value: data.value,\n                        parent: options.parentNodes ? current : null\n                    }));\n                }\n                break;\n\n            case Type.attributeName:\n                attrName = data.value;\n                current.attributes[attrName] = '';\n                break;\n\n            case Type.attributeValue:\n                current.attributes[attrName] = data.value;\n                break;\n        }\n    };\n\n    reader.reset = function () {\n        lexer = Lexer.create({ debug: options.debug });\n        lexer.on('data', handleLexerData);\n        rootNode = createNode();\n        current = null;\n        attrName = '';\n        reader.parse = lexer.write;\n    };\n\n    reader.reset();\n    return reader;\n};\n\nvar parseSync = function parseSync(xml, options) {\n    options = Object.assign({}, options, { stream: false, tagPrefix: ':' });\n    var reader = create(options);\n    var res = void 0;\n    reader.on('done', function (ast) {\n        res = ast;\n    });\n    reader.parse(xml);\n    return res;\n};\n\nmodule.exports = {\n    parseSync: parseSync,\n    create: create,\n    NodeType: NodeType\n};\n\n//# sourceURL=webpack://adhere-lib/./node_modules/xml-reader/dist/reader.js?");

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ 
/******/ // startup
/******/ // Load entry module and return exports
/******/ // This entry module can't be inlined because the eval devtool is used.
/******/ var __webpack_exports__ = __webpack_require__("./src/index.es6");
/******/ var __webpack_exports__Logger = __webpack_exports__.Logger;
/******/ var __webpack_exports__TextPresenter = __webpack_exports__.TextPresenter;
/******/ var __webpack_exports__VideoAudioHook = __webpack_exports__.VideoAudioHook;
/******/ var __webpack_exports___esModule = __webpack_exports__.__esModule;
/******/ export { __webpack_exports__Logger as Logger, __webpack_exports__TextPresenter as TextPresenter, __webpack_exports__VideoAudioHook as VideoAudioHook, __webpack_exports___esModule as __esModule };
/******/ 
